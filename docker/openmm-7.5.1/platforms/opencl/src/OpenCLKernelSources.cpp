/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2010 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "OpenCLKernelSources.h"

using namespace OpenMM;
using namespace std;

const string OpenCLKernelSources::angleForce = "real4 v0 = pos2-pos1;\n"
"real4 v1 = pos2-pos3;\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(v0)\n"
"APPLY_PERIODIC_TO_DELTA(v1)\n"
"#endif\n"
"real4 cp = cross(v0, v1);\n"
"real rp = cp.x*cp.x + cp.y*cp.y + cp.z*cp.z;\n"
"rp = max(SQRT(rp), (real) 1.0e-06f);\n"
"real r21 = v0.x*v0.x + v0.y*v0.y + v0.z*v0.z;\n"
"real r23 = v1.x*v1.x + v1.y*v1.y + v1.z*v1.z;\n"
"real dot = v0.x*v1.x + v0.y*v1.y + v0.z*v1.z;\n"
"real cosine = clamp(dot*RSQRT(r21*r23), (real) -1, (real) 1);\n"
"real theta = acos(cosine);\n"
"COMPUTE_FORCE\n"
"real4 force1 = cross(v0, cp)*(dEdAngle/(r21*rp));\n"
"real4 force3 = cross(cp, v1)*(dEdAngle/(r23*rp));\n"
"real4 force2 = -force1-force3;\n"
"";
const string OpenCLKernelSources::bondForce = "real4 delta = pos2-pos1;\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"real r = SQRT(delta.x*delta.x + delta.y*delta.y + delta.z*delta.z);\n"
"COMPUTE_FORCE\n"
"dEdR = (r > 0.0f) ? (dEdR / r) : 0.0f;\n"
"delta.xyz *= dEdR;\n"
"real4 force1 = delta;\n"
"real4 force2 = -delta;";
const string OpenCLKernelSources::common = "/**\n"
" * This file contains OpenCL definitions for the macros and functions needed for the\n"
" * common compute framework.\n"
" */\n"
"\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"\n"
"#define KERNEL __kernel\n"
"#define DEVICE\n"
"#define LOCAL __local\n"
"#define LOCAL_ARG __local\n"
"#define GLOBAL __global\n"
"#define RESTRICT restrict\n"
"#define LOCAL_ID get_local_id(0)\n"
"#define LOCAL_SIZE get_local_size(0)\n"
"#define GLOBAL_ID get_global_id(0)\n"
"#define GLOBAL_SIZE get_global_size(0)\n"
"#define GROUP_ID get_group_id(0)\n"
"#define NUM_GROUPS get_num_groups(0)\n"
"#define SYNC_THREADS barrier(CLK_LOCAL_MEM_FENCE+CLK_GLOBAL_MEM_FENCE);\n"
"#define MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE+CLK_GLOBAL_MEM_FENCE);\n"
"#define ATOMIC_ADD(dest, value) atom_add(dest, value)\n"
"\n"
"typedef long mm_long;\n"
"typedef unsigned long mm_ulong;\n"
"\n"
"#define make_short2(x...) ((short2) (x))\n"
"#define make_short3(x...) ((short3) (x))\n"
"#define make_short4(x...) ((short4) (x))\n"
"#define make_int2(x...) ((int2) (x))\n"
"#define make_int3(x...) ((int3) (x))\n"
"#define make_int4(x...) ((int4) (x))\n"
"#define make_float2(x...) ((float2) (x))\n"
"#define make_float3(x...) ((float3) (x))\n"
"#define make_float4(x...) ((float4) (x))\n"
"#define make_double2(x...) ((double2) (x))\n"
"#define make_double3(x...) ((double3) (x))\n"
"#define make_double4(x...) ((double4) (x))\n"
"\n"
"#define trimTo3(v) (v).xyz\n"
"\n"
"// OpenCL has overloaded versions of standard math functions for single and double\n"
"// precision arguments.  CUDA has separate functions.  To allow them to be called\n"
"// consistently, we define the \"single precision\" functions to just be synonyms\n"
"// for the standard ones.\n"
"\n"
"#define sqrtf(x) sqrt(x)\n"
"#define rsqrtf(x) rsqrt(x)\n"
"#define expf(x) exp(x)\n"
"#define logf(x) log(x)\n"
"#define powf(x) pow(x)\n"
"#define cosf(x) cos(x)\n"
"#define sinf(x) sin(x)\n"
"#define tanf(x) tan(x)\n"
"#define acosf(x) acos(x)\n"
"#define asinf(x) asin(x)\n"
"#define atanf(x) atan(x)\n"
"#define atan2f(x, y) atan2(x, y)\n"
"";
const string OpenCLKernelSources::compact = "/* Code for CUDA stream compaction. Roughly based on:\n"
"    Billeter M, Olsson O, Assarsson U. Efficient Stream Compaction on Wide SIMD Many-Core Architectures.\n"
"        High Performance Graphics 2009.\n"
"\n"
"    Notes:\n"
"        - paper recommends 128 threads/block, so this is hard coded.\n"
"        - I only implement the prefix-sum based compact primitive, and not the POPC one, as that is more\n"
"          complicated and performs poorly on current hardware\n"
"        - I only implement the scattered- and staged-write variant of phase III as it they have reasonable\n"
"          performance across most of the tested workloads in the paper. The selective variant is not\n"
"          implemented.\n"
"        - The prefix sum of per-block element counts (phase II) is not done in a particularly efficient\n"
"          manner. It is, however, done in a very easy to program manner, and integrated into the top of\n"
"          phase III, reducing the number of kernel invocations required. If one wanted to use existing code,\n"
"          it'd be easy to take the CUDA SDK scanLargeArray sample, and do a prefix sum over dgBlockCounts in\n"
"          a phase II kernel. You could also adapt the existing prescan128 to take an initial value, and scan\n"
"          dgBlockCounts in stages.\n"
"\n"
"  Date:         23 Aug 2009\n"
"  Author:       CUDA version by Imran Haque (ihaque@cs.stanford.edu), converted to OpenCL by Peter Eastman\n"
"  Affiliation:  Stanford University\n"
"  License:      Public Domain\n"
"*/\n"
"\n"
"// Phase 1: Count valid elements per thread block\n"
"// Hard-code 128 thd/blk\n"
"unsigned int sumReduce128(__local unsigned int* arr) {\n"
"    // Parallel reduce element counts\n"
"    // Assumes 128 thd/block\n"
"    int thread = get_local_id(0);\n"
"    if (thread < 64) arr[thread] += arr[thread+64];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"#ifdef WARPS_ARE_ATOMIC\n"
"    if (thread < 32) {\n"
"        arr[thread] += arr[thread+32];\n"
"        if (thread < 16) arr[thread] += arr[thread+16];\n"
"        if (thread < 8) arr[thread] += arr[thread+8];\n"
"        if (thread < 4) arr[thread] += arr[thread+4];\n"
"        if (thread < 2) arr[thread] += arr[thread+2];\n"
"        if (thread < 1) arr[thread] += arr[thread+1];\n"
"    }\n"
"#else\n"
"    if (thread < 32) arr[thread] += arr[thread+32];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 16) arr[thread] += arr[thread+16];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 8) arr[thread] += arr[thread+8];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 4) arr[thread] += arr[thread+4];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 2) arr[thread] += arr[thread+2];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    if (thread < 1) arr[thread] += arr[thread+1];\n"
"#endif\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    return arr[0];\n"
"}\n"
"\n"
"__kernel void countElts(__global unsigned int* restrict dgBlockCounts, __global const unsigned int* restrict dgValid, const unsigned int len, __local unsigned int* restrict dsCount) {\n"
"    dsCount[get_local_id(0)] = 0;\n"
"    unsigned int ub;\n"
"    const unsigned int eltsPerBlock = len/get_num_groups(0) + ((len % get_num_groups(0)) ? 1 : 0);\n"
"    ub = (len < (get_group_id(0)+1)*eltsPerBlock) ? len : ((get_group_id(0) + 1)*eltsPerBlock);\n"
"    for (int base = get_group_id(0) * eltsPerBlock; base < (get_group_id(0)+1)*eltsPerBlock; base += get_local_size(0)) {\n"
"        if ((base + get_local_id(0)) < ub && dgValid[base+get_local_id(0)])\n"
"            dsCount[get_local_id(0)]++;\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    unsigned int blockCount = sumReduce128(dsCount);\n"
"    if (get_local_id(0) == 0) dgBlockCounts[get_group_id(0)] = blockCount;\n"
"    return;\n"
"}\n"
"\n"
"// Phase 2/3: Move valid elements using SIMD compaction (phase 2 is done implicitly at top of __global__ method)\n"
"// Exclusive prefix scan over 128 elements\n"
"// Assumes 128 threads\n"
"// Taken from cuda SDK \"scan\" sample for naive scan, with small modifications\n"
"int exclusivePrescan128(__local const unsigned int* in, __local unsigned int* outAndTemp) {\n"
"    const int n=128;\n"
"    //TODO: this temp storage could be reduced since we write to shared memory in out anyway, and n is hardcoded\n"
"    //__shared__ int temp[2*n];\n"
"    __local unsigned int* temp = outAndTemp;\n"
"    int pout = 1, pin = 0;\n"
"\n"
"    // load input into temp\n"
"    // This is exclusive scan, so shift right by one and set first elt to 0\n"
"    int thread = get_local_id(0);\n"
"    temp[pout*n + get_local_id(0)] = (get_local_id(0) > 0) ? in[get_local_id(0)-1] : 0;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    for (int offset = 1; offset < n; offset *= 2)\n"
"    {\n"
"        pout = 1 - pout; // swap double buffer indices\n"
"        pin  = 1 - pout;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        temp[pout*n+get_local_id(0)] = temp[pin*n+get_local_id(0)];\n"
"        if (get_local_id(0) >= offset)\n"
"            temp[pout*n+get_local_id(0)] += temp[pin*n+get_local_id(0) - offset];\n"
"    }\n"
"\n"
"    //out[get_local_id(0)] = temp[pout*n+get_local_id(0)]; // write output\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    return outAndTemp[127]+in[127]; // Return sum of all elements\n"
"}\n"
"\n"
"int compactSIMDPrefixSum(__local const unsigned int* dsData, __local const unsigned int* dsValid, __local unsigned int* dsCompact, __local unsigned int* dsLocalIndex) {\n"
"    int numValid = exclusivePrescan128(dsValid,dsLocalIndex);\n"
"    int thread = get_local_id(0);\n"
"    if (dsValid[get_local_id(0)]) dsCompact[dsLocalIndex[get_local_id(0)]] = dsData[get_local_id(0)];\n"
"    return numValid;\n"
"}\n"
"\n"
"__kernel void moveValidElementsStaged(__global const unsigned int* restrict dgData, __global unsigned int* restrict dgCompact, __global const unsigned int* restrict dgValid,\n"
"            __global const unsigned int* restrict dgBlockCounts, unsigned int len, __global unsigned int* restrict dNumValidElements,\n"
"            __local unsigned int* restrict inBlock, __local unsigned int* restrict validBlock, __local unsigned int* restrict compactBlock) {\n"
"    __local unsigned int dsLocalIndex[256];\n"
"    int blockOutOffset=0;\n"
"    // Sum up the blockCounts before us to find our offset\n"
"    // This is totally inefficient - lots of repeated work b/w blocks, and uneven balancing.\n"
"    // Paper implements this as a prefix sum kernel in phase II\n"
"    // May still be faster than an extra kernel invocation?\n"
"    int thread = get_local_id(0);\n"
"    for (int base = 0; base < get_group_id(0); base += get_local_size(0)) {\n"
"        // Load up the count of valid elements for each block before us in batches of 128\n"
"        if ((base + get_local_id(0)) < get_group_id(0)) {\n"
"            validBlock[get_local_id(0)] = dgBlockCounts[base+get_local_id(0)];\n"
"        } else {\n"
"            validBlock[get_local_id(0)] = 0;\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        // Parallel reduce these counts\n"
"        // Accumulate in the final offset variable\n"
"        blockOutOffset += sumReduce128(validBlock);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"\n"
"    unsigned int ub;\n"
"    const unsigned int eltsPerBlock = len/get_num_groups(0) + ((len % get_num_groups(0)) ? 1 : 0);\n"
"    ub = (len < (get_group_id(0)+1)*eltsPerBlock) ? len : ((get_group_id(0) + 1)*eltsPerBlock);\n"
"    for (int base = get_group_id(0) * eltsPerBlock; base < (get_group_id(0)+1)*eltsPerBlock; base += get_local_size(0)) {\n"
"        if ((base + get_local_id(0)) < ub) {\n"
"            validBlock[get_local_id(0)] = dgValid[base+get_local_id(0)];\n"
"            inBlock[get_local_id(0)] = dgData[base+get_local_id(0)];\n"
"        } else {\n"
"            validBlock[get_local_id(0)] = 0;\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        int numValidBlock = compactSIMDPrefixSum(inBlock,validBlock,compactBlock,dsLocalIndex);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (get_local_id(0) < numValidBlock) {\n"
"            dgCompact[blockOutOffset + get_local_id(0)] = compactBlock[get_local_id(0)];\n"
"        }\n"
"        blockOutOffset += numValidBlock;\n"
"    }\n"
"    if (get_group_id(0) == (get_num_groups(0)-1) && get_local_id(0) == 0) {\n"
"        *dNumValidElements = blockOutOffset;\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::constraints = "__kernel void applyPositionDeltas(__global real4* restrict posq, __global real4* restrict posqCorrection, __global mixed4* restrict posDelta) {\n"
"    for (unsigned int index = get_global_id(0); index < NUM_ATOMS; index += get_global_size(0)) {\n"
"#ifdef USE_MIXED_PRECISION\n"
"        real4 pos1 = posq[index];\n"
"        real4 pos2 = posqCorrection[index];\n"
"        mixed4 pos = (mixed4) (pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"        mixed4 pos = posq[index];\n"
"#endif\n"
"        pos.xyz += posDelta[index].xyz;\n"
"#ifdef USE_MIXED_PRECISION\n"
"        posq[index] = (real4) ((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"        posqCorrection[index] = (real4) (pos.x-(real) pos.x, pos.y-(real) pos.y, pos.z-(real) pos.z, 0);\n"
"#else\n"
"        posq[index] = pos;\n"
"#endif\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::coulombLennardJones = "{\n"
"#ifdef USE_DOUBLE_PRECISION\n"
"    unsigned long includeInteraction;\n"
"#else\n"
"    unsigned int includeInteraction;\n"
"#endif\n"
"#if USE_EWALD\n"
"    includeInteraction = (!isExcluded && r2 < CUTOFF_SQUARED);\n"
"    const real alphaR = EWALD_ALPHA*r;\n"
"    const real expAlphaRSqr = EXP(-alphaR*alphaR);\n"
"#if HAS_COULOMB\n"
"    const real prefactor = ONE_4PI_EPS0*CHARGE1*CHARGE2*invR;\n"
"#else\n"
"    const real prefactor = 0.0f;\n"
"#endif\n"
"\n"
"#ifdef USE_DOUBLE_PRECISION\n"
"    const real erfcAlphaR = erfc(alphaR);\n"
"#else\n"
"    // This approximation for erfc is from Abramowitz and Stegun (1964) p. 299.  They cite the following as\n"
"    // the original source: C. Hastings, Jr., Approximations for Digital Computers (1955).  It has a maximum\n"
"    // error of 1.5e-7.\n"
"\n"
"    const real t = RECIP(1.0f+0.3275911f*alphaR);\n"
"    const real erfcAlphaR = (0.254829592f+(-0.284496736f+(1.421413741f+(-1.453152027f+1.061405429f*t)*t)*t)*t)*t*expAlphaRSqr;\n"
"#endif\n"
"    real tempForce = 0;\n"
"#if HAS_LENNARD_JONES\n"
"    real sig = SIGMA_EPSILON1.x + SIGMA_EPSILON2.x;\n"
"    real sig2 = invR*sig;\n"
"    sig2 *= sig2;\n"
"    real sig6 = sig2*sig2*sig2;\n"
"    real eps = SIGMA_EPSILON1.y*SIGMA_EPSILON2.y;\n"
"    real epssig6 = sig6*eps;\n"
"    tempForce = epssig6*(12.0f*sig6 - 6.0f);\n"
"    real ljEnergy = epssig6*(sig6 - 1.0f);\n"
"    #if USE_LJ_SWITCH\n"
"    if (r > LJ_SWITCH_CUTOFF) {\n"
"        real x = r-LJ_SWITCH_CUTOFF;\n"
"        real switchValue = 1+x*x*x*(LJ_SWITCH_C3+x*(LJ_SWITCH_C4+x*LJ_SWITCH_C5));\n"
"        real switchDeriv = x*x*(3*LJ_SWITCH_C3+x*(4*LJ_SWITCH_C4+x*5*LJ_SWITCH_C5));\n"
"        tempForce = tempForce*switchValue - ljEnergy*switchDeriv*r;\n"
"        ljEnergy *= switchValue;\n"
"    }\n"
"    #endif\n"
"#if DO_LJPME\n"
"    // The multiplicative term to correct for the multiplicative terms that are always\n"
"    // present in reciprocal space.\n"
"    const real dispersionAlphaR = EWALD_DISPERSION_ALPHA*r;\n"
"    const real dar2 = dispersionAlphaR*dispersionAlphaR;\n"
"    const real dar4 = dar2*dar2;\n"
"    const real dar6 = dar4*dar2;\n"
"    const real invR2 = invR*invR;\n"
"    const real expDar2 = EXP(-dar2);\n"
"    const float2 sigExpProd = SIGMA_EPSILON1*SIGMA_EPSILON2;\n"
"    const real c6 = 64*sigExpProd.x*sigExpProd.x*sigExpProd.x*sigExpProd.y;\n"
"    const real coef = invR2*invR2*invR2*c6;\n"
"    const real eprefac = 1.0f + dar2 + 0.5f*dar4;\n"
"    const real dprefac = eprefac + dar6/6.0f;\n"
"    // The multiplicative grid term\n"
"    ljEnergy += coef*(1.0f - expDar2*eprefac);\n"
"    tempForce += 6.0f*coef*(1.0f - expDar2*dprefac);\n"
"    // The potential shift accounts for the step at the cutoff introduced by the\n"
"    // transition from additive to multiplicative combintion rules and is only\n"
"    // needed for the real (not excluded) terms.  By addin these terms to ljEnergy\n"
"    // instead of tempEnergy here, the includeInteraction mask is correctly applied.\n"
"    sig2 = sig*sig;\n"
"    sig6 = sig2*sig2*sig2*INVCUT6;\n"
"    epssig6 = eps*sig6;\n"
"    // The additive part of the potential shift\n"
"    ljEnergy += epssig6*(1.0f - sig6);\n"
"    // The multiplicative part of the potential shift\n"
"    ljEnergy += MULTSHIFT6*c6;\n"
"#endif\n"
"    tempForce += prefactor*(erfcAlphaR+alphaR*expAlphaRSqr*TWO_OVER_SQRT_PI);\n"
"    tempEnergy += select((real) 0, ljEnergy + prefactor*erfcAlphaR, includeInteraction);\n"
"#else\n"
"    tempForce = prefactor*(erfcAlphaR+alphaR*expAlphaRSqr*TWO_OVER_SQRT_PI);\n"
"    tempEnergy += select((real) 0, prefactor*erfcAlphaR, includeInteraction);\n"
"#endif\n"
"    dEdR += select((real) 0, tempForce*invR*invR, includeInteraction);\n"
"#else\n"
"#ifdef USE_CUTOFF\n"
"    includeInteraction = (!isExcluded && r2 < CUTOFF_SQUARED);\n"
"#else\n"
"    includeInteraction = (!isExcluded);\n"
"#endif\n"
"    real tempForce = 0;\n"
"  #if HAS_LENNARD_JONES\n"
"    real sig = SIGMA_EPSILON1.x + SIGMA_EPSILON2.x;\n"
"    real sig2 = invR*sig;\n"
"    sig2 *= sig2;\n"
"    real sig6 = sig2*sig2*sig2;\n"
"    real epssig6 = sig6*(SIGMA_EPSILON1.y*SIGMA_EPSILON2.y);\n"
"    tempForce = epssig6*(12.0f*sig6 - 6.0f);\n"
"    real ljEnergy = epssig6*(sig6-1);\n"
"    #if USE_LJ_SWITCH\n"
"    if (r > LJ_SWITCH_CUTOFF) {\n"
"        real x = r-LJ_SWITCH_CUTOFF;\n"
"        real switchValue = 1+x*x*x*(LJ_SWITCH_C3+x*(LJ_SWITCH_C4+x*LJ_SWITCH_C5));\n"
"        real switchDeriv = x*x*(3*LJ_SWITCH_C3+x*(4*LJ_SWITCH_C4+x*5*LJ_SWITCH_C5));\n"
"        tempForce = tempForce*switchValue - ljEnergy*switchDeriv*r;\n"
"        ljEnergy *= switchValue;\n"
"    }\n"
"    #endif\n"
"    ljEnergy = select((real) 0, ljEnergy, includeInteraction);\n"
"    tempEnergy += ljEnergy;\n"
"  #endif\n"
"#if HAS_COULOMB\n"
"  #ifdef USE_CUTOFF\n"
"    const real prefactor = ONE_4PI_EPS0*CHARGE1*CHARGE2;\n"
"    tempForce += prefactor*(invR - 2.0f*REACTION_FIELD_K*r2);\n"
"    tempEnergy += select((real) 0, prefactor*(invR + REACTION_FIELD_K*r2 - REACTION_FIELD_C), includeInteraction);\n"
"  #else\n"
"    const real prefactor = ONE_4PI_EPS0*CHARGE1*CHARGE2*invR;\n"
"    tempForce += prefactor;\n"
"    tempEnergy += select((real) 0, prefactor, includeInteraction);\n"
"  #endif\n"
"#endif\n"
"    dEdR += select((real) 0, tempForce*invR*invR, includeInteraction);\n"
"#endif\n"
"}\n"
"";
const string OpenCLKernelSources::customCVForce = "/**\n"
" * Copy the positions and velocities to the inner context.\n"
" */\n"
"__kernel void copyState(__global real4* posq, __global real4* posqCorrection, __global mixed4* velm, __global int* restrict atomOrder,\n"
"        __global real4* innerPosq, __global real4* innerPosqCorrection, __global mixed4* innerVelm, __global int* restrict innerInvAtomOrder,\n"
"        int numAtoms) {\n"
"    for (int i = get_global_id(0); i < numAtoms; i += get_global_size(0)) {\n"
"        int index = innerInvAtomOrder[atomOrder[i]];\n"
"        innerPosq[index] = posq[i];\n"
"        innerVelm[index] = velm[i];\n"
"#ifdef USE_MIXED_PRECISION\n"
"        innerPosqCorrection[index] = posqCorrection[i];\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Copy the forces back to the main context.\n"
" */\n"
"__kernel void copyForces(__global real4* forces, __global int* restrict invAtomOrder, __global real4* innerForces,\n"
"        __global int* restrict innerAtomOrder, int numAtoms) {\n"
"    for (int i = get_global_id(0); i < numAtoms; i += get_global_size(0)) {\n"
"        int index = invAtomOrder[innerAtomOrder[i]];\n"
"        forces[index] = innerForces[i];\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Add all the forces from the CVs.\n"
" */\n"
"__kernel void addForces(__global real4* forces, int numAtoms\n"
"    PARAMETER_ARGUMENTS) {\n"
"    for (int i = get_global_id(0); i < numAtoms; i += get_global_size(0)) {\n"
"        real4 f = forces[i];\n"
"        ADD_FORCES\n"
"        forces[i] = f;\n"
"    }\n"
"}";
const string OpenCLKernelSources::ewald = "real2 multofReal2(real2 a, real2 b) {\n"
"    return (real2) (a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n"
"}\n"
"\n"
"/**\n"
" * Precompute the cosine and sine sums which appear in each force term.\n"
" */\n"
"\n"
"__kernel void calculateEwaldCosSinSums(__global mixed* restrict energyBuffer, __global const real4* restrict posq, __global real2* restrict cosSinSum, real4 reciprocalPeriodicBoxSize, real reciprocalCoefficient) {\n"
"    const unsigned int ksizex = 2*KMAX_X-1;\n"
"    const unsigned int ksizey = 2*KMAX_Y-1;\n"
"    const unsigned int ksizez = 2*KMAX_Z-1;\n"
"    const unsigned int totalK = ksizex*ksizey*ksizez;\n"
"    unsigned int index = get_global_id(0);\n"
"    mixed energy = 0;\n"
"    while (index < (KMAX_Y-1)*ksizez+KMAX_Z)\n"
"        index += get_global_size(0);\n"
"    while (index < totalK) {\n"
"        // Find the wave vector (kx, ky, kz) this index corresponds to.\n"
"\n"
"        int rx = index/(ksizey*ksizez);\n"
"        int remainder = index - rx*ksizey*ksizez;\n"
"        int ry = remainder/ksizez;\n"
"        int rz = remainder - ry*ksizez - KMAX_Z + 1;\n"
"        ry += -KMAX_Y + 1;\n"
"        real kx = rx*reciprocalPeriodicBoxSize.x;\n"
"        real ky = ry*reciprocalPeriodicBoxSize.y;\n"
"        real kz = rz*reciprocalPeriodicBoxSize.z;\n"
"\n"
"        // Compute the sum for this wave vector.\n"
"\n"
"        real2 sum = 0.0f;\n"
"        for (int atom = 0; atom < NUM_ATOMS; atom++) {\n"
"            real4 apos = posq[atom];\n"
"            real phase = apos.x*kx;\n"
"            real2 structureFactor = (real2) (cos(phase), sin(phase));\n"
"            phase = apos.y*ky;\n"
"            structureFactor = multofReal2(structureFactor, (real2) (cos(phase), sin(phase)));\n"
"            phase = apos.z*kz;\n"
"            structureFactor = multofReal2(structureFactor, (real2) (cos(phase), sin(phase)));\n"
"            sum += apos.w*structureFactor;\n"
"        }\n"
"        cosSinSum[index] = sum;\n"
"\n"
"        // Compute the contribution to the energy.\n"
"\n"
"        real k2 = kx*kx + ky*ky + kz*kz;\n"
"        real ak = EXP(k2*EXP_COEFFICIENT) / k2;\n"
"        energy += reciprocalCoefficient*ak*(sum.x*sum.x + sum.y*sum.y);\n"
"        index += get_global_size(0);\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"\n"
"/**\n"
" * Compute the reciprocal space part of the Ewald force, using the precomputed sums from the\n"
" * previous routine.\n"
" */\n"
"\n"
"__kernel void calculateEwaldForces(__global real4* restrict forceBuffers, __global const real4* restrict posq, __global const real2* restrict cosSinSum, real4 reciprocalPeriodicBoxSize, real reciprocalCoefficient) {\n"
"    unsigned int atom = get_global_id(0);\n"
"    while (atom < NUM_ATOMS) {\n"
"        real4 force = forceBuffers[atom];\n"
"        real4 apos = posq[atom];\n"
"\n"
"        // Loop over all wave vectors.\n"
"\n"
"        int lowry = 0;\n"
"        int lowrz = 1;\n"
"        for (int rx = 0; rx < KMAX_X; rx++) {\n"
"            real kx = rx*reciprocalPeriodicBoxSize.x;\n"
"            for (int ry = lowry; ry < KMAX_Y; ry++) {\n"
"                real ky = ry*reciprocalPeriodicBoxSize.y;\n"
"                real phase = apos.x*kx;\n"
"                real2 tab_xy = (real2) (cos(phase), sin(phase));\n"
"                phase = apos.y*ky;\n"
"                tab_xy = multofReal2(tab_xy, (real2) (cos(phase), sin(phase)));\n"
"                for (int rz = lowrz; rz < KMAX_Z; rz++) {\n"
"                    real kz = rz*reciprocalPeriodicBoxSize.z;\n"
"\n"
"                    // Compute the force contribution of this wave vector.\n"
"\n"
"                    int index = rx*(KMAX_Y*2-1)*(KMAX_Z*2-1) + (ry+KMAX_Y-1)*(KMAX_Z*2-1) + (rz+KMAX_Z-1);\n"
"                    real k2 = kx*kx + ky*ky + kz*kz;\n"
"                    real ak = EXP(k2*EXP_COEFFICIENT)/k2;\n"
"                    phase = apos.z*kz;\n"
"                    real2 structureFactor = multofReal2(tab_xy, (real2) (cos(phase), sin(phase)));\n"
"                    real2 sum = cosSinSum[index];\n"
"                    real dEdR = 2*reciprocalCoefficient*ak*apos.w*(sum.x*structureFactor.y - sum.y*structureFactor.x);\n"
"                    force.x += dEdR*kx;\n"
"                    force.y += dEdR*ky;\n"
"                    force.z += dEdR*kz;\n"
"                    lowrz = 1 - KMAX_Z;\n"
"                }\n"
"                lowry = 1 - KMAX_Y;\n"
"            }\n"
"        }\n"
"\n"
"        // Record the force on the atom.\n"
"\n"
"        forceBuffers[atom] = force;\n"
"        atom += get_global_size(0);\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::fft = "real2 multiplyComplex(real2 c1, real2 c2) {\n"
"    return (real2) (c1.x*c2.x-c1.y*c2.y, c1.x*c2.y+c1.y*c2.x);\n"
"}\n"
"\n"
"/**\n"
" * Load a value from the half-complex grid produces by a real-to-complex transform.\n"
" */\n"
"real2 loadComplexValue(__global const real2* restrict in, int x, int y, int z) {\n"
"    const int inputZSize = ZSIZE/2+1;\n"
"    if (z < inputZSize)\n"
"        return in[x*YSIZE*inputZSize+y*inputZSize+z];\n"
"    int xp = (x == 0 ? 0 : XSIZE-x);\n"
"    int yp = (y == 0 ? 0 : YSIZE-y);\n"
"    real2 value = in[xp*YSIZE*inputZSize+yp*inputZSize+(ZSIZE-z)];\n"
"    return (real2) (value.x, -value.y);\n"
"}\n"
"\n"
"/**\n"
" * Perform a 1D FFT on each row along one axis.\n"
" */\n"
"\n"
"__kernel void execFFT(__global const INPUT_TYPE* restrict in, __global OUTPUT_TYPE* restrict out, __local real2* restrict w,\n"
"        __local real2* restrict data0, __local real2* restrict data1) {\n"
"    for (int i = get_local_id(0); i < ZSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (cos(-(SIGN)*i*2*M_PI/ZSIZE), sin(-(SIGN)*i*2*M_PI/ZSIZE));\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    \n"
"    for (int baseIndex = get_group_id(0)*BLOCKS_PER_GROUP; baseIndex < XSIZE*YSIZE; baseIndex += get_num_groups(0)*BLOCKS_PER_GROUP) {\n"
"        int index = baseIndex+get_local_id(0)/ZSIZE;\n"
"        int x = index/YSIZE;\n"
"        int y = index-x*YSIZE;\n"
"#if OUTPUT_IS_PACKED\n"
"        if (x < XSIZE/2+1) {\n"
"#endif\n"
"#if LOOP_REQUIRED\n"
"        for (int z = get_local_id(0); z < ZSIZE; z += get_local_size(0))\n"
"    #if INPUT_IS_REAL\n"
"            data0[z] = (real2) (in[x*(YSIZE*ZSIZE)+y*ZSIZE+z], 0);\n"
"    #elif INPUT_IS_PACKED\n"
"            data0[z] = loadComplexValue(in, x, y, z);\n"
"    #else\n"
"            data0[z] = in[x*(YSIZE*ZSIZE)+y*ZSIZE+z];\n"
"    #endif\n"
"#else\n"
"        if (index < XSIZE*YSIZE)\n"
"    #if INPUT_IS_REAL\n"
"            data0[get_local_id(0)] = (real2) (in[x*(YSIZE*ZSIZE)+y*ZSIZE+get_local_id(0)%ZSIZE], 0);\n"
"    #elif INPUT_IS_PACKED\n"
"            data0[get_local_id(0)] = loadComplexValue(in, x, y, get_local_id(0)%ZSIZE);\n"
"    #else\n"
"            data0[get_local_id(0)] = in[x*(YSIZE*ZSIZE)+y*ZSIZE+get_local_id(0)%ZSIZE];\n"
"    #endif\n"
"#endif\n"
"#if OUTPUT_IS_PACKED\n"
"        }\n"
"#endif\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        COMPUTE_FFT\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::fftR2C = "/**\n"
" * Combine the two halves of a real grid into a complex grid that is half as large.\n"
" */\n"
"__kernel void packForwardData(__global const real* restrict in, __global real2* restrict out) {\n"
"    const int gridSize = PACKED_XSIZE*PACKED_YSIZE*PACKED_ZSIZE;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int x = index/(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int remainder = index-x*(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int y = remainder/PACKED_ZSIZE;\n"
"        int z = remainder-y*PACKED_ZSIZE;\n"
"#if PACKED_AXIS == 0\n"
"        real2 value = (real2) (in[2*x*YSIZE*ZSIZE+y*ZSIZE+z], in[(2*x+1)*YSIZE*ZSIZE+y*ZSIZE+z]);\n"
"#elif PACKED_AXIS == 1\n"
"        real2 value = (real2) (in[x*YSIZE*ZSIZE+2*y*ZSIZE+z], in[x*YSIZE*ZSIZE+(2*y+1)*ZSIZE+z]);\n"
"#else\n"
"        real2 value = (real2) (in[x*YSIZE*ZSIZE+y*ZSIZE+2*z], in[x*YSIZE*ZSIZE+y*ZSIZE+(2*z+1)]);\n"
"#endif\n"
"        out[index] = value;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Split the transformed data back into a full sized, symmetric grid.\n"
" */\n"
"__kernel void unpackForwardData(__global const real2* restrict in, __global real2* restrict out, __local real2* restrict w) {\n"
"    // Compute the phase factors.\n"
"    \n"
"#if PACKED_AXIS == 0\n"
"    for (int i = get_local_id(0); i < PACKED_XSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (sin(i*2*M_PI/XSIZE), cos(i*2*M_PI/XSIZE));\n"
"#elif PACKED_AXIS == 1\n"
"    for (int i = get_local_id(0); i < PACKED_YSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (sin(i*2*M_PI/YSIZE), cos(i*2*M_PI/YSIZE));\n"
"#else\n"
"    for (int i = get_local_id(0); i < PACKED_ZSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (sin(i*2*M_PI/ZSIZE), cos(i*2*M_PI/ZSIZE));\n"
"#endif\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Transform the data.\n"
"    \n"
"    const int gridSize = PACKED_XSIZE*PACKED_YSIZE*PACKED_ZSIZE;\n"
"    const int outputZSize = ZSIZE/2+1;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int x = index/(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int remainder = index-x*(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int y = remainder/PACKED_ZSIZE;\n"
"        int z = remainder-y*PACKED_ZSIZE;\n"
"        int xp = (x == 0 ? 0 : PACKED_XSIZE-x);\n"
"        int yp = (y == 0 ? 0 : PACKED_YSIZE-y);\n"
"        int zp = (z == 0 ? 0 : PACKED_ZSIZE-z);\n"
"        real2 z1 = in[x*PACKED_YSIZE*PACKED_ZSIZE+y*PACKED_ZSIZE+z];\n"
"        real2 z2 = in[xp*PACKED_YSIZE*PACKED_ZSIZE+yp*PACKED_ZSIZE+zp];\n"
"#if PACKED_AXIS == 0\n"
"        real2 wfac = w[x];\n"
"#elif PACKED_AXIS == 1\n"
"        real2 wfac = w[y];\n"
"#else\n"
"        real2 wfac = w[z];\n"
"#endif\n"
"        real2 output = (real2) ((z1.x+z2.x - wfac.x*(z1.x-z2.x) + wfac.y*(z1.y+z2.y))/2, (z1.y-z2.y - wfac.y*(z1.x-z2.x) - wfac.x*(z1.y+z2.y))/2);\n"
"        if (z < outputZSize)\n"
"            out[x*YSIZE*outputZSize+y*outputZSize+z] = output;\n"
"        xp = (x == 0 ? 0 : XSIZE-x);\n"
"        yp = (y == 0 ? 0 : YSIZE-y);\n"
"        zp = (z == 0 ? 0 : ZSIZE-z);\n"
"        if (zp < outputZSize) {\n"
"#if PACKED_AXIS == 0\n"
"            if (x == 0)\n"
"                out[PACKED_XSIZE*YSIZE*outputZSize+yp*outputZSize+zp] = (real2) ((z1.x-z1.y+z2.x-z2.y)/2, (-z1.x-z1.y+z2.x+z2.y)/2);\n"
"#elif PACKED_AXIS == 1\n"
"            if (y == 0)\n"
"                out[xp*YSIZE*outputZSize+PACKED_YSIZE*outputZSize+zp] = (real2) ((z1.x-z1.y+z2.x-z2.y)/2, (-z1.x-z1.y+z2.x+z2.y)/2);\n"
"#else\n"
"            if (z == 0)\n"
"                out[xp*YSIZE*outputZSize+yp*outputZSize+PACKED_ZSIZE] = (real2) ((z1.x-z1.y+z2.x-z2.y)/2, (-z1.x-z1.y+z2.x+z2.y)/2);\n"
"#endif\n"
"            else\n"
"                out[xp*YSIZE*outputZSize+yp*outputZSize+zp] = (real2) (output.x, -output.y);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Load a value from the half-complex grid produced by a real-to-complex transform.\n"
" */\n"
"real2 loadComplexValue(__global const real2* restrict in, int x, int y, int z) {\n"
"    const int inputZSize = ZSIZE/2+1;\n"
"    if (z < inputZSize)\n"
"        return in[x*YSIZE*inputZSize+y*inputZSize+z];\n"
"    int xp = (x == 0 ? 0 : XSIZE-x);\n"
"    int yp = (y == 0 ? 0 : YSIZE-y);\n"
"    real2 value = in[xp*YSIZE*inputZSize+yp*inputZSize+(ZSIZE-z)];\n"
"    return (real2) (value.x, -value.y);\n"
"}\n"
"\n"
"/**\n"
" * Repack the symmetric complex grid into one half as large in preparation for doing an inverse complex-to-real transform.\n"
" */\n"
"__kernel void packBackwardData(__global const real2* restrict in, __global real2* restrict out, __local real2* restrict w) {\n"
"    // Compute the phase factors.\n"
"    \n"
"#if PACKED_AXIS == 0\n"
"    for (int i = get_local_id(0); i < PACKED_XSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (cos(i*2*M_PI/XSIZE), sin(i*2*M_PI/XSIZE));\n"
"#elif PACKED_AXIS == 1\n"
"    for (int i = get_local_id(0); i < PACKED_YSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (cos(i*2*M_PI/YSIZE), sin(i*2*M_PI/YSIZE));\n"
"#else\n"
"    for (int i = get_local_id(0); i < PACKED_ZSIZE; i += get_local_size(0))\n"
"        w[i] = (real2) (cos(i*2*M_PI/ZSIZE), sin(i*2*M_PI/ZSIZE));\n"
"#endif\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Transform the data.\n"
"    \n"
"    const int gridSize = PACKED_XSIZE*PACKED_YSIZE*PACKED_ZSIZE;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int x = index/(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int remainder = index-x*(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int y = remainder/PACKED_ZSIZE;\n"
"        int z = remainder-y*PACKED_ZSIZE;\n"
"        int xp = (x == 0 ? 0 : PACKED_XSIZE-x);\n"
"        int yp = (y == 0 ? 0 : PACKED_YSIZE-y);\n"
"        int zp = (z == 0 ? 0 : PACKED_ZSIZE-z);\n"
"        real2 z1 = loadComplexValue(in, x, y, z);\n"
"#if PACKED_AXIS == 0\n"
"        real2 wfac = w[x];\n"
"        real2 z2 = loadComplexValue(in, PACKED_XSIZE-x, yp, zp);\n"
"#elif PACKED_AXIS == 1\n"
"        real2 wfac = w[y];\n"
"        real2 z2 = loadComplexValue(in, xp, PACKED_YSIZE-y, zp);\n"
"#else\n"
"        real2 wfac = w[z];\n"
"        real2 z2 = loadComplexValue(in, xp, yp, PACKED_ZSIZE-z);\n"
"#endif\n"
"        real2 even = (real2) ((z1.x+z2.x)/2, (z1.y-z2.y)/2);\n"
"        real2 odd = (real2) ((z1.x-z2.x)/2, (z1.y+z2.y)/2);\n"
"        odd = (real2) (odd.x*wfac.x-odd.y*wfac.y, odd.y*wfac.x+odd.x*wfac.y);\n"
"        out[x*PACKED_YSIZE*PACKED_ZSIZE+y*PACKED_ZSIZE+z] = (real2) (even.x-odd.y, even.y+odd.x);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Split the data back into a full sized, real grid after an inverse transform.\n"
" */\n"
"__kernel void unpackBackwardData(__global const real2* restrict in, __global real* restrict out) {\n"
"    const int gridSize = PACKED_XSIZE*PACKED_YSIZE*PACKED_ZSIZE;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int x = index/(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int remainder = index-x*(PACKED_YSIZE*PACKED_ZSIZE);\n"
"        int y = remainder/PACKED_ZSIZE;\n"
"        int z = remainder-y*PACKED_ZSIZE;\n"
"        real2 value = 2*in[index];\n"
"#if PACKED_AXIS == 0\n"
"        out[2*x*YSIZE*ZSIZE+y*ZSIZE+z] = value.x;\n"
"        out[(2*x+1)*YSIZE*ZSIZE+y*ZSIZE+z] = value.y;\n"
"#elif PACKED_AXIS == 1\n"
"        out[x*YSIZE*ZSIZE+2*y*ZSIZE+z] = value.x;\n"
"        out[x*YSIZE*ZSIZE+(2*y+1)*ZSIZE+z] = value.y;\n"
"#else\n"
"        out[x*YSIZE*ZSIZE+y*ZSIZE+2*z] = value.x;\n"
"        out[x*YSIZE*ZSIZE+y*ZSIZE+(2*z+1)] = value.y;\n"
"#endif\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::findInteractingBlocks = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n"
"\n"
"/**\n"
" * Find a bounding box for the atoms in each block.\n"
" */\n"
"__kernel void findBlockBounds(int numAtoms, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        __global const real4* restrict posq, __global real4* restrict blockCenter, __global real4* restrict blockBoundingBox, __global int* restrict rebuildNeighborList,\n"
"        __global real2* restrict sortedBlocks) {\n"
"    int index = get_global_id(0);\n"
"    int base = index*TILE_SIZE;\n"
"    while (base < numAtoms) {\n"
"        real4 pos = posq[base];\n"
"#ifdef USE_PERIODIC\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"#endif\n"
"        real4 minPos = pos;\n"
"        real4 maxPos = pos;\n"
"        int last = min(base+TILE_SIZE, numAtoms);\n"
"        for (int i = base+1; i < last; i++) {\n"
"            pos = posq[i];\n"
"#ifdef USE_PERIODIC\n"
"            real4 center = 0.5f*(maxPos+minPos);\n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, center)\n"
"#endif\n"
"            minPos = min(minPos, pos);\n"
"            maxPos = max(maxPos, pos);\n"
"        }\n"
"        real4 blockSize = 0.5f*(maxPos-minPos);\n"
"        real4 center = 0.5f*(maxPos+minPos);\n"
"        center.w = 0;\n"
"        for (int i = base; i < last; i++) {\n"
"            pos = posq[i];\n"
"            real4 delta = posq[i]-center;\n"
"#ifdef USE_PERIODIC\n"
"            APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"            center.w = max(center.w, delta.x*delta.x+delta.y*delta.y+delta.z*delta.z);\n"
"        }\n"
"        center.w = sqrt(center.w);\n"
"        blockBoundingBox[index] = blockSize;\n"
"        blockCenter[index] = center;\n"
"        sortedBlocks[index] = (real2) (blockSize.x+blockSize.y+blockSize.z, index);\n"
"        index += get_global_size(0);\n"
"        base = index*TILE_SIZE;\n"
"    }\n"
"    if (get_global_id(0) == 0)\n"
"        rebuildNeighborList[0] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Sort the data about bounding boxes so it can be accessed more efficiently in the next kernel.\n"
" */\n"
"__kernel void sortBoxData(__global const real2* restrict sortedBlock, __global const real4* restrict blockCenter,\n"
"        __global const real4* restrict blockBoundingBox, __global real4* restrict sortedBlockCenter,\n"
"        __global real4* restrict sortedBlockBoundingBox, __global const real4* restrict posq, __global const real4* restrict oldPositions,\n"
"        __global unsigned int* restrict interactionCount, __global int* restrict rebuildNeighborList, int forceRebuild) {\n"
"    for (int i = get_global_id(0); i < NUM_BLOCKS; i += get_global_size(0)) {\n"
"        int index = (int) sortedBlock[i].y;\n"
"        sortedBlockCenter[i] = blockCenter[index];\n"
"        sortedBlockBoundingBox[i] = blockBoundingBox[index];\n"
"    }\n"
"    \n"
"    // Also check whether any atom has moved enough so that we really need to rebuild the neighbor list.\n"
"\n"
"    bool rebuild = forceRebuild;\n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0)) {\n"
"        real4 delta = oldPositions[i]-posq[i];\n"
"        if (delta.x*delta.x + delta.y*delta.y + delta.z*delta.z > 0.25f*PADDING*PADDING)\n"
"            rebuild = true;\n"
"    }\n"
"    if (rebuild) {\n"
"        rebuildNeighborList[0] = 1;\n"
"        interactionCount[0] = 0;\n"
"    }\n"
"}\n"
"\n"
"#if SIMD_WIDTH <= 32\n"
"\n"
"#define BUFFER_SIZE 256\n"
"\n"
"__kernel void findBlocksWithInteractions(real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        __global unsigned int* restrict interactionCount, __global int* restrict interactingTiles, __global unsigned int* restrict interactingAtoms,\n"
"        __global const real4* restrict posq, unsigned int maxTiles, unsigned int startBlockIndex, unsigned int numBlocks, __global real2* restrict sortedBlocks,\n"
"        __global const real4* restrict sortedBlockCenter, __global const real4* restrict sortedBlockBoundingBox,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices, __global real4* restrict oldPositions,\n"
"        __global const int* restrict rebuildNeighborList) {\n"
"\n"
"    if (rebuildNeighborList[0] == 0)\n"
"        return; // The neighbor list doesn't need to be rebuilt.\n"
"\n"
"    const int indexInWarp = get_local_id(0)%32;\n"
"    const int warpStart = get_local_id(0)-indexInWarp;\n"
"    const int totalWarps = get_global_size(0)/32;\n"
"    const int warpIndex = get_global_id(0)/32;\n"
"    const int warpMask = (1<<indexInWarp)-1;\n"
"    __local int workgroupBuffer[BUFFER_SIZE*(GROUP_SIZE/32)];\n"
"    __local int warpExclusions[MAX_EXCLUSIONS*(GROUP_SIZE/32)];\n"
"    __local real3 posBuffer[GROUP_SIZE];\n"
"    __local volatile int workgroupTileIndex[GROUP_SIZE/32];\n"
"    __local bool includeBlockFlags[GROUP_SIZE];\n"
"    __local volatile short2 atomCountBuffer[GROUP_SIZE];\n"
"    __local int* buffer = workgroupBuffer+BUFFER_SIZE*(warpStart/32);\n"
"    __local int* exclusionsForX = warpExclusions+MAX_EXCLUSIONS*(warpStart/32);\n"
"    __local volatile int* tileStartIndex = workgroupTileIndex+(warpStart/32);\n"
"\n"
"    // Loop over blocks.\n"
"\n"
"    for (int block1 = startBlockIndex+warpIndex; block1 < startBlockIndex+numBlocks; block1 += totalWarps) {\n"
"        // Load data for this block.  Note that all threads in a warp are processing the same block.\n"
"        \n"
"        real2 sortedKey = sortedBlocks[block1];\n"
"        int x = (int) sortedKey.y;\n"
"        real4 blockCenterX = sortedBlockCenter[block1];\n"
"        real4 blockSizeX = sortedBlockBoundingBox[block1];\n"
"        int neighborsInBuffer = 0;\n"
"        real3 pos1 = posq[x*TILE_SIZE+indexInWarp].xyz;\n"
"#ifdef USE_PERIODIC\n"
"        const bool singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= PADDED_CUTOFF &&\n"
"                                         0.5f*periodicBoxSize.y-blockSizeX.y >= PADDED_CUTOFF &&\n"
"                                         0.5f*periodicBoxSize.z-blockSizeX.z >= PADDED_CUTOFF);\n"
"        if (singlePeriodicCopy) {\n"
"            // The box is small enough that we can just translate all the atoms into a single periodic\n"
"            // box, then skip having to apply periodic boundary conditions later.\n"
"            \n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos1, blockCenterX)\n"
"        }\n"
"#endif\n"
"        posBuffer[get_local_id(0)] = pos1;\n"
"\n"
"        // Load exclusion data for block x.\n"
"        \n"
"        const int exclusionStart = exclusionRowIndices[x];\n"
"        const int exclusionEnd = exclusionRowIndices[x+1];\n"
"        const int numExclusions = exclusionEnd-exclusionStart;\n"
"        for (int j = indexInWarp; j < numExclusions; j += 32)\n"
"            exclusionsForX[j] = exclusionIndices[exclusionStart+j];\n"
"        if (MAX_EXCLUSIONS > 32)\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        else\n"
"            SYNC_WARPS;\n"
"        \n"
"        // Loop over atom blocks to search for neighbors.  The threads in a warp compare block1 against 32\n"
"        // other blocks in parallel.\n"
"\n"
"        for (int block2Base = block1+1; block2Base < NUM_BLOCKS; block2Base += 32) {\n"
"            int block2 = block2Base+indexInWarp;\n"
"            bool includeBlock2 = (block2 < NUM_BLOCKS);\n"
"            if (includeBlock2) {\n"
"                real4 blockCenterY = sortedBlockCenter[block2];\n"
"                real4 blockSizeY = sortedBlockBoundingBox[block2];\n"
"                real4 blockDelta = blockCenterX-blockCenterY;\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(blockDelta)\n"
"#endif\n"
"                includeBlock2 &= (blockDelta.x*blockDelta.x+blockDelta.y*blockDelta.y+blockDelta.z*blockDelta.z < (PADDED_CUTOFF+blockCenterX.w+blockCenterY.w)*(PADDED_CUTOFF+blockCenterX.w+blockCenterY.w));\n"
"                blockDelta.x = max((real) 0, fabs(blockDelta.x)-blockSizeX.x-blockSizeY.x);\n"
"                blockDelta.y = max((real) 0, fabs(blockDelta.y)-blockSizeX.y-blockSizeY.y);\n"
"                blockDelta.z = max((real) 0, fabs(blockDelta.z)-blockSizeX.z-blockSizeY.z);\n"
"                includeBlock2 &= (blockDelta.x*blockDelta.x+blockDelta.y*blockDelta.y+blockDelta.z*blockDelta.z < PADDED_CUTOFF_SQUARED);\n"
"#ifdef TRICLINIC\n"
"                // The calculation to find the nearest periodic copy is only guaranteed to work if the nearest copy is less than half a box width away.\n"
"                // If there's any possibility we might have missed it, do a detailed check.\n"
"\n"
"                if (periodicBoxSize.z/2-blockSizeX.z-blockSizeY.z < PADDED_CUTOFF || periodicBoxSize.y/2-blockSizeX.y-blockSizeY.y < PADDED_CUTOFF)\n"
"                    includeBlock2 = true;\n"
"#endif\n"
"                if (includeBlock2) {\n"
"                    int y = (int) sortedBlocks[block2].y;\n"
"                    for (int k = 0; k < numExclusions; k++)\n"
"                        includeBlock2 &= (exclusionsForX[k] != y);\n"
"                }\n"
"            }\n"
"            \n"
"            // Loop over any blocks we identified as potentially containing neighbors.\n"
"            \n"
"            includeBlockFlags[get_local_id(0)] = includeBlock2;\n"
"            SYNC_WARPS;\n"
"            for (int i = 0; i < TILE_SIZE; i++) {\n"
"                while (i < TILE_SIZE && !includeBlockFlags[warpStart+i])\n"
"                    i++;\n"
"                if (i < TILE_SIZE) {\n"
"                    int y = (int) sortedBlocks[block2Base+i].y;\n"
"\n"
"                    // Check each atom in block Y for interactions.\n"
"\n"
"                    int atom2 = y*TILE_SIZE+indexInWarp;\n"
"                    real3 pos2 = posq[atom2].xyz;\n"
"#ifdef USE_PERIODIC\n"
"                    if (singlePeriodicCopy)\n"
"                        APPLY_PERIODIC_TO_POS_WITH_CENTER(pos2, blockCenterX)\n"
"#endif\n"
"                    bool interacts = false;\n"
"                    if (atom2 < NUM_ATOMS) {\n"
"#ifdef USE_PERIODIC\n"
"                        if (!singlePeriodicCopy) {\n"
"                            for (int j = 0; j < TILE_SIZE; j++) {\n"
"                                real3 delta = pos2-posBuffer[warpStart+j];\n"
"                                APPLY_PERIODIC_TO_DELTA(delta)\n"
"                                interacts |= (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                            }\n"
"                        }\n"
"                        else {\n"
"#endif\n"
"                            for (int j = 0; j < TILE_SIZE; j++) {\n"
"                                real3 delta = pos2-posBuffer[warpStart+j];\n"
"                                interacts |= (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                            }\n"
"#ifdef USE_PERIODIC\n"
"                        }\n"
"#endif\n"
"                    }\n"
"                    \n"
"                    // Do a prefix sum to compact the list of atoms.\n"
"\n"
"                    atomCountBuffer[get_local_id(0)].x = (interacts ? 1 : 0);\n"
"                    SYNC_WARPS;\n"
"                    int whichBuffer = 0;\n"
"                    for (int offset = 1; offset < TILE_SIZE; offset *= 2) {\n"
"                        if (whichBuffer == 0)\n"
"                            atomCountBuffer[get_local_id(0)].y = (indexInWarp < offset ? atomCountBuffer[get_local_id(0)].x : atomCountBuffer[get_local_id(0)].x+atomCountBuffer[get_local_id(0)-offset].x);\n"
"                        else\n"
"                            atomCountBuffer[get_local_id(0)].x = (indexInWarp < offset ? atomCountBuffer[get_local_id(0)].y : atomCountBuffer[get_local_id(0)].y+atomCountBuffer[get_local_id(0)-offset].y);\n"
"                        whichBuffer = 1-whichBuffer;\n"
"                        SYNC_WARPS;\n"
"                    }\n"
"                    \n"
"                    // Add any interacting atoms to the buffer.\n"
"\n"
"                    if (interacts)\n"
"                        buffer[neighborsInBuffer+atomCountBuffer[get_local_id(0)].y-1] = atom2;\n"
"                    neighborsInBuffer += atomCountBuffer[warpStart+TILE_SIZE-1].y;\n"
"                    if (neighborsInBuffer > BUFFER_SIZE-TILE_SIZE) {\n"
"                        // Store the new tiles to memory.\n"
"\n"
"                        int tilesToStore = neighborsInBuffer/TILE_SIZE;\n"
"                        if (indexInWarp == 0)\n"
"                            *tileStartIndex = atom_add(interactionCount, tilesToStore);\n"
"                        SYNC_WARPS;\n"
"                        int newTileStartIndex = *tileStartIndex;\n"
"                        if (newTileStartIndex+tilesToStore <= maxTiles) {\n"
"                            if (indexInWarp < tilesToStore)\n"
"                                interactingTiles[newTileStartIndex+indexInWarp] = x;\n"
"                            for (int j = 0; j < tilesToStore; j++)\n"
"                                interactingAtoms[(newTileStartIndex+j)*TILE_SIZE+indexInWarp] = buffer[indexInWarp+j*TILE_SIZE];\n"
"                        }\n"
"                        if (indexInWarp+TILE_SIZE*tilesToStore < BUFFER_SIZE)\n"
"                            buffer[indexInWarp] = buffer[indexInWarp+TILE_SIZE*tilesToStore];\n"
"                        neighborsInBuffer -= TILE_SIZE*tilesToStore;\n"
"                   }\n"
"                }\n"
"            }\n"
"        }\n"
"        \n"
"        // If we have a partially filled buffer,  store it to memory.\n"
"        \n"
"        if (neighborsInBuffer > 0) {\n"
"            int tilesToStore = (neighborsInBuffer+TILE_SIZE-1)/TILE_SIZE;\n"
"            if (indexInWarp == 0)\n"
"                *tileStartIndex = atom_add(interactionCount, tilesToStore);\n"
"            SYNC_WARPS;\n"
"            int newTileStartIndex = *tileStartIndex;\n"
"            if (newTileStartIndex+tilesToStore <= maxTiles) {\n"
"                if (indexInWarp < tilesToStore)\n"
"                    interactingTiles[newTileStartIndex+indexInWarp] = x;\n"
"                for (int j = 0; j < tilesToStore; j++)\n"
"                    interactingAtoms[(newTileStartIndex+j)*TILE_SIZE+indexInWarp] = (indexInWarp+j*TILE_SIZE < neighborsInBuffer ? buffer[indexInWarp+j*TILE_SIZE] : NUM_ATOMS);\n"
"            }\n"
"        }\n"
"    }\n"
"    \n"
"    // Record the positions the neighbor list is based on.\n"
"    \n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0))\n"
"        oldPositions[i] = posq[i];\n"
"}\n"
"\n"
"#else\n"
"// This is the old implementation of finding interacting blocks.  It is quite a bit more complicated,\n"
"// and slower on most GPUs.  On AMD, however, it is faster, so we keep it around to use there.\n"
"\n"
"#define BUFFER_SIZE BUFFER_GROUPS*GROUP_SIZE\n"
"#define WARP_SIZE 32\n"
"#define INVALID -1\n"
"\n"
"/**\n"
" * Perform a parallel prefix sum over an array.  The input values are all assumed to be 0 or 1.\n"
" */\n"
"void prefixSum(__local int* sum, __local int2* temp) {\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"        temp[i].x = sum[i];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    int whichBuffer = 0;\n"
"    for (int offset = 1; offset < BUFFER_SIZE; offset *= 2) {\n"
"        if (whichBuffer == 0)\n"
"            for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"                temp[i].y = (i < offset ? temp[i].x : temp[i].x+temp[i-offset].x);\n"
"        else\n"
"            for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"                temp[i].x = (i < offset ? temp[i].y : temp[i].y+temp[i-offset].y);\n"
"        whichBuffer = 1-whichBuffer;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    if (whichBuffer == 0)\n"
"        for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"            sum[i] = temp[i].x;\n"
"    else\n"
"        for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"            sum[i] = temp[i].y;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"\n"
"/**\n"
" * This is called by findBlocksWithInteractions().  It compacts the list of blocks, identifies interactions\n"
" * in them, and writes the result to global memory.\n"
" */\n"
"void storeInteractionData(int x, __local int* buffer, __local int* sum, __local int2* temp, __local int* atoms, __local int* numAtoms,\n"
"            __local int* baseIndex, __global unsigned int* interactionCount, __global int* interactingTiles, __global unsigned int* interactingAtoms, real4 periodicBoxSize,\n"
"            real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, __global const real4* posq, __local real4* posBuffer,\n"
"            real4 blockCenterX, real4 blockSizeX, unsigned int maxTiles, bool finish) {\n"
"    const bool singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= PADDED_CUTOFF &&\n"
"                                     0.5f*periodicBoxSize.y-blockSizeX.y >= PADDED_CUTOFF &&\n"
"                                     0.5f*periodicBoxSize.z-blockSizeX.z >= PADDED_CUTOFF);\n"
"    if (get_local_id(0) < TILE_SIZE) {\n"
"        real4 pos = posq[x*TILE_SIZE+get_local_id(0)];\n"
"#ifdef USE_PERIODIC\n"
"        if (singlePeriodicCopy) {\n"
"            // The box is small enough that we can just translate all the atoms into a single periodic\n"
"            // box, then skip having to apply periodic boundary conditions later.\n"
"            \n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, blockCenterX)\n"
"        }\n"
"#endif\n"
"        posBuffer[get_local_id(0)] = pos;\n"
"    }\n"
"    \n"
"    // The buffer is full, so we need to compact it and write out results.  Start by doing a parallel prefix sum.\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"        sum[i] = (buffer[i] == INVALID ? 0 : 1);\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    prefixSum(sum, temp);\n"
"    int numValid = sum[BUFFER_SIZE-1];\n"
"\n"
"    // Compact the buffer.\n"
"\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"        if (buffer[i] != INVALID)\n"
"            temp[sum[i]-1].x = buffer[i];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"        buffer[i] = temp[i].x;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Loop over the tiles and find specific interactions in them.\n"
"\n"
"    const int indexInWarp = get_local_id(0)%WARP_SIZE;\n"
"    for (int base = 0; base < numValid; base += BUFFER_SIZE/WARP_SIZE) {\n"
"        for (int i = get_local_id(0)/WARP_SIZE; i < BUFFER_SIZE/WARP_SIZE && base+i < numValid; i += GROUP_SIZE/WARP_SIZE) {\n"
"            // Check each atom in block Y for interactions.\n"
"            \n"
"            real4 pos = posq[buffer[base+i]*TILE_SIZE+indexInWarp];\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy)\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, blockCenterX)\n"
"#endif\n"
"            bool interacts = false;\n"
"#ifdef USE_PERIODIC\n"
"            if (!singlePeriodicCopy) {\n"
"                for (int j = 0; j < TILE_SIZE; j++) {\n"
"                    real4 delta = pos-posBuffer[j];\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"                    interacts |= (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                }\n"
"            }\n"
"            else {\n"
"#endif\n"
"                for (int j = 0; j < TILE_SIZE; j++) {\n"
"                    real4 delta = pos-posBuffer[j];\n"
"                    interacts |= (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                }\n"
"#ifdef USE_PERIODIC\n"
"            }\n"
"#endif\n"
"            sum[i*WARP_SIZE+indexInWarp] = (interacts ? 1 : 0);\n"
"        }\n"
"        for (int i = numValid-base+get_local_id(0)/WARP_SIZE; i < BUFFER_SIZE/WARP_SIZE; i += GROUP_SIZE/WARP_SIZE)\n"
"            sum[i*WARP_SIZE+indexInWarp] = 0;\n"
"\n"
"        // Compact the list of atoms.\n"
"\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        prefixSum(sum, temp);\n"
"        for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"            if (sum[i] != (i == 0 ? 0 : sum[i-1]))\n"
"                atoms[*numAtoms+sum[i]-1] = buffer[base+i/WARP_SIZE]*TILE_SIZE+indexInWarp;\n"
"\n"
"        // Store them to global memory.\n"
"\n"
"        int atomsToStore = *numAtoms+sum[BUFFER_SIZE-1];\n"
"        bool storePartialTile = (finish && base >= numValid-BUFFER_SIZE/WARP_SIZE);\n"
"        int tilesToStore = (storePartialTile ? (atomsToStore+TILE_SIZE-1)/TILE_SIZE : atomsToStore/TILE_SIZE);\n"
"        if (tilesToStore > 0) {\n"
"            if (get_local_id(0) == 0)\n"
"                *baseIndex = atom_add(interactionCount, tilesToStore);\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) == 0)\n"
"                *numAtoms = atomsToStore-tilesToStore*TILE_SIZE;\n"
"            if (*baseIndex+tilesToStore <= maxTiles) {\n"
"                if (get_local_id(0) < tilesToStore)\n"
"                    interactingTiles[*baseIndex+get_local_id(0)] = x;\n"
"                for (int i = get_local_id(0); i < tilesToStore*TILE_SIZE; i += get_local_size(0))\n"
"                    interactingAtoms[*baseIndex*TILE_SIZE+i] = (i < atomsToStore ? atoms[i] : NUM_ATOMS);\n"
"            }\n"
"        }\n"
"        else {\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (get_local_id(0) == 0)\n"
"                *numAtoms += sum[BUFFER_SIZE-1];\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (get_local_id(0) < *numAtoms && !storePartialTile)\n"
"            atoms[get_local_id(0)] = atoms[tilesToStore*TILE_SIZE+get_local_id(0)];\n"
"    }\n"
"\n"
"    if (numValid == 0 && *numAtoms > 0 && finish) {\n"
"        // We didn't have any more tiles to process, but there were some atoms left over from a\n"
"        // previous call to this function.  Save them now.\n"
"\n"
"        if (get_local_id(0) == 0)\n"
"            *baseIndex = atom_add(interactionCount, 1);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (*baseIndex < maxTiles) {\n"
"            if (get_local_id(0) == 0)\n"
"                interactingTiles[*baseIndex] = x;\n"
"            if (get_local_id(0) < TILE_SIZE)\n"
"                interactingAtoms[*baseIndex*TILE_SIZE+get_local_id(0)] = (get_local_id(0) < *numAtoms ? atoms[get_local_id(0)] : NUM_ATOMS);\n"
"        }\n"
"    }\n"
"\n"
"    // Reset the buffer for processing more tiles.\n"
"\n"
"    for (int i = get_local_id(0); i < BUFFER_SIZE; i += get_local_size(0))\n"
"        buffer[i] = INVALID;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"\n"
"/**\n"
" * Compare the bounding boxes for each pair of blocks.  If they are sufficiently far apart,\n"
" * mark them as non-interacting.\n"
" */\n"
"__kernel void findBlocksWithInteractions(real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        __global unsigned int* restrict interactionCount, __global int* restrict interactingTiles, __global unsigned int* restrict interactingAtoms,\n"
"        __global const real4* restrict posq, unsigned int maxTiles, unsigned int startBlockIndex, unsigned int numBlocks, __global real2* restrict sortedBlocks,\n"
"        __global const real4* restrict sortedBlockCenter, __global const real4* restrict sortedBlockBoundingBox,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices, __global real4* restrict oldPositions,\n"
"        __global const int* restrict rebuildNeighborList) {\n"
"    __local int buffer[BUFFER_SIZE];\n"
"    __local int sum[BUFFER_SIZE];\n"
"    __local int2 temp[BUFFER_SIZE];\n"
"    __local int atoms[BUFFER_SIZE+TILE_SIZE];\n"
"    __local real4 posBuffer[TILE_SIZE];\n"
"    __local int exclusionsForX[MAX_EXCLUSIONS];\n"
"    __local int bufferFull;\n"
"    __local int globalIndex;\n"
"    __local int numAtoms;\n"
"#ifdef AMD_ATOMIC_WORK_AROUND\n"
"    // Do a byte write to force all memory accesses to interactionCount to use the complete path.\n"
"    // This avoids the atomic access from causing all word accesses to other buffers from using the slow complete path.\n"
"    // The IF actually causes the write to never be executed, its presence is all that is needed.\n"
"    // AMD APP SDK 2.4 has this problem.\n"
"    if (get_global_id(0) == get_local_id(0)+1)\n"
"        ((__global char*)interactionCount)[sizeof(unsigned int)+1] = 0;\n"
"#endif\n"
"\n"
"    if (rebuildNeighborList[0] == 0)\n"
"        return; // The neighbor list doesn't need to be rebuilt.\n"
"\n"
"    int valuesInBuffer = 0;\n"
"    if (get_local_id(0) == 0)\n"
"        bufferFull = false;\n"
"    for (int i = 0; i < BUFFER_GROUPS; ++i)\n"
"        buffer[i*GROUP_SIZE+get_local_id(0)] = INVALID;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    \n"
"    // Loop over blocks sorted by size.\n"
"    \n"
"    for (int i = startBlockIndex+get_group_id(0); i < startBlockIndex+numBlocks; i += get_num_groups(0)) {\n"
"        if (get_local_id(0) == get_local_size(0)-1)\n"
"            numAtoms = 0;\n"
"        real2 sortedKey = sortedBlocks[i];\n"
"        int x = (int) sortedKey.y;\n"
"        real4 blockCenterX = sortedBlockCenter[i];\n"
"        real4 blockSizeX = sortedBlockBoundingBox[i];\n"
"\n"
"        // Load exclusion data for block x.\n"
"        \n"
"        const int exclusionStart = exclusionRowIndices[x];\n"
"        const int exclusionEnd = exclusionRowIndices[x+1];\n"
"        const int numExclusions = exclusionEnd-exclusionStart;\n"
"        for (int j = get_local_id(0); j < numExclusions; j += get_local_size(0))\n"
"            exclusionsForX[j] = exclusionIndices[exclusionStart+j];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        \n"
"        // Compare it to other blocks after this one in sorted order.\n"
"\n"
"        for (int base = i+1; base < NUM_BLOCKS; base += get_local_size(0)) {\n"
"            int j = base+get_local_id(0);\n"
"            real2 sortedKey2 = (j < NUM_BLOCKS ? sortedBlocks[j] : (real2) 0);\n"
"            real4 blockCenterY = (j < NUM_BLOCKS ? sortedBlockCenter[j] : (real4) 0);\n"
"            real4 blockSizeY = (j < NUM_BLOCKS ? sortedBlockBoundingBox[j] : (real4) 0);\n"
"            int y = (int) sortedKey2.y;\n"
"            real4 delta = blockCenterX-blockCenterY;\n"
"#ifdef USE_PERIODIC\n"
"            APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"            delta.x = max((real) 0, fabs(delta.x)-blockSizeX.x-blockSizeY.x);\n"
"            delta.y = max((real) 0, fabs(delta.y)-blockSizeX.y-blockSizeY.y);\n"
"            delta.z = max((real) 0, fabs(delta.z)-blockSizeX.z-blockSizeY.z);\n"
"            bool hasExclusions = false;\n"
"            for (int k = 0; k < numExclusions; k++)\n"
"                hasExclusions |= (exclusionsForX[k] == y);\n"
"            if (j < NUM_BLOCKS && delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED && !hasExclusions) {\n"
"                // Add this tile to the buffer.\n"
"\n"
"                int bufferIndex = valuesInBuffer*GROUP_SIZE+get_local_id(0);\n"
"                buffer[bufferIndex] = y;\n"
"                valuesInBuffer++;\n"
"                if (!bufferFull && valuesInBuffer == BUFFER_GROUPS)\n"
"                    bufferFull = true;\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (bufferFull) {\n"
"                storeInteractionData(x, buffer, sum, temp, atoms, &numAtoms, &globalIndex, interactionCount, interactingTiles, interactingAtoms, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ, posq, posBuffer, blockCenterX, blockSizeX, maxTiles, false);\n"
"                valuesInBuffer = 0;\n"
"                if (get_local_id(0) == 0)\n"
"                    bufferFull = false;\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"        storeInteractionData(x, buffer, sum, temp, atoms, &numAtoms, &globalIndex, interactionCount, interactingTiles, interactingAtoms, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ, posq, posBuffer, blockCenterX, blockSizeX, maxTiles, true);\n"
"    }\n"
"    \n"
"    // Record the positions the neighbor list is based on.\n"
"    \n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0))\n"
"        oldPositions[i] = posq[i];\n"
"}\n"
"\n"
"#endif\n"
"\n"
"";
const string OpenCLKernelSources::findInteractingBlocks_cpu = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n"
"#define BUFFER_SIZE BUFFER_GROUPS*GROUP_SIZE\n"
"\n"
"/**\n"
" * Find a bounding box for the atoms in each block.\n"
" */\n"
"__kernel void findBlockBounds(int numAtoms, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        __global const real4* restrict posq, __global real4* restrict blockCenter, __global real4* restrict blockBoundingBox, __global int* restrict rebuildNeighborList,\n"
"        __global real2* restrict sortedBlocks) {\n"
"    int index = get_global_id(0);\n"
"    int base = index*TILE_SIZE;\n"
"    while (base < numAtoms) {\n"
"        real4 pos = posq[base];\n"
"#ifdef USE_PERIODIC\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"#endif\n"
"        real4 minPos = pos;\n"
"        real4 maxPos = pos;\n"
"        int last = min(base+TILE_SIZE, numAtoms);\n"
"        for (int i = base+1; i < last; i++) {\n"
"            pos = posq[i];\n"
"#ifdef USE_PERIODIC\n"
"            real4 center = 0.5f*(maxPos+minPos);\n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, center)\n"
"#endif\n"
"            minPos = min(minPos, pos);\n"
"            maxPos = max(maxPos, pos);\n"
"        }\n"
"        real4 blockSize = 0.5f*(maxPos-minPos);\n"
"        blockBoundingBox[index] = blockSize;\n"
"        blockCenter[index] = 0.5f*(maxPos+minPos);\n"
"        sortedBlocks[index] = (real2) (blockSize.x+blockSize.y+blockSize.z, index);\n"
"        index += get_global_size(0);\n"
"        base = index*TILE_SIZE;\n"
"    }\n"
"    if (get_global_id(0) == 0)\n"
"        rebuildNeighborList[0] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Sort the data about bounding boxes so it can be accessed more efficiently in the next kernel.\n"
" */\n"
"__kernel void sortBoxData(__global const real2* restrict sortedBlock, __global const real4* restrict blockCenter,\n"
"        __global const real4* restrict blockBoundingBox, __global real4* restrict sortedBlockCenter,\n"
"        __global real4* restrict sortedBlockBoundingBox, __global const real4* restrict posq, __global const real4* restrict oldPositions,\n"
"        __global unsigned int* restrict interactionCount, __global int* restrict rebuildNeighborList, int forceRebuild) {\n"
"    for (int i = get_global_id(0); i < NUM_BLOCKS; i += get_global_size(0)) {\n"
"        int index = (int) sortedBlock[i].y;\n"
"        sortedBlockCenter[i] = blockCenter[index];\n"
"        sortedBlockBoundingBox[i] = blockBoundingBox[index];\n"
"    }\n"
"    \n"
"    // Also check whether any atom has moved enough so that we really need to rebuild the neighbor list.\n"
"\n"
"    bool rebuild = forceRebuild;\n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0)) {\n"
"        real4 delta = oldPositions[i]-posq[i];\n"
"        if (delta.x*delta.x + delta.y*delta.y + delta.z*delta.z > 0.25f*PADDING*PADDING)\n"
"            rebuild = true;\n"
"    }\n"
"    if (rebuild) {\n"
"        rebuildNeighborList[0] = 1;\n"
"        interactionCount[0] = 0;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * This is called by findBlocksWithInteractions().  It compacts the list of blocks and writes them\n"
" * to global memory.\n"
" */\n"
"void storeInteractionData(int x, int* buffer, int* atoms, int* numAtoms, int numValid, __global unsigned int* interactionCount,\n"
"            __global int* interactingTiles, __global unsigned int* interactingAtoms, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX,\n"
"            real4 periodicBoxVecY, real4 periodicBoxVecZ, __global const real4* posq, real4 blockCenterX, real4 blockSizeX, unsigned int maxTiles, bool finish) {\n"
"    real4 posBuffer[TILE_SIZE];\n"
"    const bool singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= PADDED_CUTOFF &&\n"
"                                     0.5f*periodicBoxSize.y-blockSizeX.y >= PADDED_CUTOFF &&\n"
"                                     0.5f*periodicBoxSize.z-blockSizeX.z >= PADDED_CUTOFF);\n"
"    for (int i = 0; i < TILE_SIZE; i++) {\n"
"        real4 pos = posq[x*TILE_SIZE+i];\n"
"#ifdef USE_PERIODIC\n"
"        if (singlePeriodicCopy) {\n"
"            // The box is small enough that we can just translate all the atoms into a single periodic\n"
"            // box, then skip having to apply periodic boundary conditions later.\n"
"            \n"
"            APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, blockCenterX)\n"
"        }\n"
"#endif\n"
"        posBuffer[i] = pos;\n"
"    }\n"
"\n"
"    // Loop over the tiles and find specific interactions in them.\n"
"\n"
"    for (int tile = 0; tile < numValid; tile++) {\n"
"        for (int indexInTile = 0; indexInTile < TILE_SIZE; indexInTile++) {\n"
"            // Check each atom in block Y for interactions.\n"
"            \n"
"            int atom = buffer[tile]*TILE_SIZE+indexInTile;\n"
"            real4 pos = posq[atom];\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy)\n"
"		APPLY_PERIODIC_TO_POS_WITH_CENTER(pos, blockCenterX)\n"
"#endif\n"
"            bool interacts = false;\n"
"#ifdef USE_PERIODIC\n"
"            if (!singlePeriodicCopy) {\n"
"                for (int j = 0; j < TILE_SIZE && !interacts; j++) {\n"
"                    real4 delta = pos-posBuffer[j];\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"                    interacts = (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                }\n"
"            }\n"
"            else {\n"
"#endif\n"
"                for (int j = 0; j < TILE_SIZE && !interacts; j++) {\n"
"                    real4 delta = pos-posBuffer[j];\n"
"                    interacts = (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED);\n"
"                }\n"
"#ifdef USE_PERIODIC\n"
"            }\n"
"#endif\n"
"            if (interacts)\n"
"                atoms[(*numAtoms)++] = atom;\n"
"            if (*numAtoms == BUFFER_SIZE) {\n"
"                // The atoms buffer is full, so store it to global memory.\n"
"                \n"
"                int tilesToStore = BUFFER_SIZE/TILE_SIZE;\n"
"                int baseIndex = atom_add(interactionCount, tilesToStore);\n"
"                if (baseIndex+tilesToStore <= maxTiles) {\n"
"                    for (int i = 0; i < tilesToStore; i++) {\n"
"                        interactingTiles[baseIndex+i] = x;\n"
"                        for (int j = 0; j < TILE_SIZE; j++)\n"
"                            interactingAtoms[(baseIndex+i)*TILE_SIZE+j] = atoms[i*TILE_SIZE+j];\n"
"                    }\n"
"                }\n"
"                *numAtoms = 0;\n"
"            }\n"
"        }\n"
"    }\n"
"    \n"
"    if (*numAtoms > 0 && finish) {\n"
"        // There are some leftover atoms, so save them now.\n"
"        \n"
"        int tilesToStore = (*numAtoms+TILE_SIZE-1)/TILE_SIZE;\n"
"        int baseIndex = atom_add(interactionCount, tilesToStore);\n"
"        if (baseIndex+tilesToStore <= maxTiles) {\n"
"            for (int i = 0; i < tilesToStore; i++) {\n"
"                interactingTiles[baseIndex+i] = x;\n"
"                for (int j = 0; j < TILE_SIZE; j++) {\n"
"                    int index = i*TILE_SIZE+j;\n"
"                    interactingAtoms[(baseIndex+i)*TILE_SIZE+j] = (index < *numAtoms ? atoms[index] : NUM_ATOMS);\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Compare the bounding boxes for each pair of blocks.  If they are sufficiently far apart,\n"
" * mark them as non-interacting.\n"
" */\n"
"__kernel void findBlocksWithInteractions(real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        __global unsigned int* restrict interactionCount, __global int* restrict interactingTiles, __global unsigned int* restrict interactingAtoms,\n"
"        __global const real4* restrict posq, unsigned int maxTiles, unsigned int startBlockIndex, unsigned int numBlocks, __global real2* restrict sortedBlocks,\n"
"        __global const real4* restrict sortedBlockCenter, __global const real4* restrict sortedBlockBoundingBox,\n"
"        __global const unsigned int* restrict exclusionIndices, __global const unsigned int* restrict exclusionRowIndices, __global real4* restrict oldPositions,\n"
"        __global const int* restrict rebuildNeighborList) {\n"
"    if (rebuildNeighborList[0] == 0)\n"
"        return; // The neighbor list doesn't need to be rebuilt.\n"
"    int buffer[BUFFER_SIZE];\n"
"    int atoms[BUFFER_SIZE];\n"
"    int exclusionsForX[MAX_EXCLUSIONS];\n"
"    int valuesInBuffer;\n"
"    int numAtoms;\n"
"    \n"
"    // Loop over blocks sorted by size.\n"
"    \n"
"    for (int i = startBlockIndex+get_group_id(0); i < startBlockIndex+numBlocks; i += get_num_groups(0)) {\n"
"        valuesInBuffer = 0;\n"
"        numAtoms = 0;\n"
"        real2 sortedKey = sortedBlocks[i];\n"
"        int x = (int) sortedKey.y;\n"
"        real4 blockCenterX = sortedBlockCenter[i];\n"
"        real4 blockSizeX = sortedBlockBoundingBox[i];\n"
"\n"
"        // Load exclusion data for block x.\n"
"        \n"
"        const int exclusionStart = exclusionRowIndices[x];\n"
"        const int exclusionEnd = exclusionRowIndices[x+1];\n"
"        const int numExclusions = exclusionEnd-exclusionStart;\n"
"        for (int j = 0; j < numExclusions; j++)\n"
"            exclusionsForX[j] = exclusionIndices[exclusionStart+j];\n"
"        \n"
"        // Compare it to other blocks after this one in sorted order.\n"
"        \n"
"        for (int j = i+1; j < NUM_BLOCKS; j++) {\n"
"            real2 sortedKey2 = sortedBlocks[j];\n"
"            int y = (int) sortedKey2.y;\n"
"            bool hasExclusions = false;\n"
"            for (int k = 0; k < numExclusions; k++)\n"
"                hasExclusions |= (exclusionsForX[k] == y);\n"
"            if (hasExclusions)\n"
"                continue;\n"
"            real4 blockCenterY = sortedBlockCenter[j];\n"
"            real4 blockSizeY = sortedBlockBoundingBox[j];\n"
"            real4 delta = blockCenterX-blockCenterY;\n"
"#ifdef USE_PERIODIC\n"
"            APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"            delta.x = max((real) 0, fabs(delta.x)-blockSizeX.x-blockSizeY.x);\n"
"            delta.y = max((real) 0, fabs(delta.y)-blockSizeX.y-blockSizeY.y);\n"
"            delta.z = max((real) 0, fabs(delta.z)-blockSizeX.z-blockSizeY.z);\n"
"            if (delta.x*delta.x+delta.y*delta.y+delta.z*delta.z < PADDED_CUTOFF_SQUARED) {\n"
"                // Add this tile to the buffer.\n"
"\n"
"                buffer[valuesInBuffer++] = y;\n"
"                if (valuesInBuffer == BUFFER_SIZE) {\n"
"                    storeInteractionData(x, buffer, atoms, &numAtoms, valuesInBuffer, interactionCount, interactingTiles, interactingAtoms, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ, posq, blockCenterX, blockSizeX, maxTiles, false);\n"
"                    valuesInBuffer = 0;\n"
"                }\n"
"            }\n"
"        }\n"
"        storeInteractionData(x, buffer, atoms, &numAtoms, valuesInBuffer, interactionCount, interactingTiles, interactingAtoms, periodicBoxSize, invPeriodicBoxSize, periodicBoxVecX, periodicBoxVecY, periodicBoxVecZ, posq, blockCenterX, blockSizeX, maxTiles, true);\n"
"    }\n"
"    \n"
"    // Record the positions the neighbor list is based on.\n"
"    \n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0))\n"
"        oldPositions[i] = posq[i];\n"
"}\n"
"";
const string OpenCLKernelSources::monteCarloBarostat = "/**\n"
" * Scale the particle positions with each axis independent.\n"
" */\n"
"\n"
"__kernel void scalePositions(float scaleX, float scaleY, float scaleZ, int numMolecules, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, __global real4* restrict posq,\n"
"        __global const int* restrict moleculeAtoms, __global const int* restrict moleculeStartIndex) {\n"
"    for (int index = get_global_id(0); index < numMolecules; index += get_global_size(0)) {\n"
"        int first = moleculeStartIndex[index];\n"
"        int last = moleculeStartIndex[index+1];\n"
"        int numAtoms = last-first;\n"
"\n"
"        // Find the center of each molecule.\n"
"\n"
"        real3 center = (real3) 0;\n"
"        for (int atom = first; atom < last; atom++)\n"
"            center += posq[moleculeAtoms[atom]].xyz;\n"
"        center /= (real) numAtoms;\n"
"\n"
"        // Move it into the first periodic box.\n"
"\n"
"        real3 oldCenter = center;\n"
"        APPLY_PERIODIC_TO_POS(center)\n"
"        real3 delta = oldCenter-center;;\n"
"        real3 scaleXYZ = (real3) (scaleX, scaleY, scaleZ);\n"
"\n"
"        // Now scale the position of the molecule center.\n"
"\n"
"        delta = center*(scaleXYZ-1)-delta;\n"
"        for (int atom = first; atom < last; atom++) {\n"
"            real4 pos = posq[moleculeAtoms[atom]];\n"
"            pos.xyz += delta.xyz;\n"
"            posq[moleculeAtoms[atom]] = pos;\n"
"        }\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::nonbonded = "#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"#define WARPS_PER_GROUP (FORCE_WORK_GROUP_SIZE/TILE_SIZE)\n"
"\n"
"typedef struct {\n"
"    real x, y, z;\n"
"    real q;\n"
"    real fx, fy, fz;\n"
"    ATOM_PARAMETER_DATA\n"
"#ifndef PARAMETER_SIZE_IS_EVEN\n"
"    real padding;\n"
"#endif\n"
"} AtomData;\n"
"\n"
"/**\n"
" * Compute nonbonded interactions.\n"
" */\n"
"__kernel void computeNonbonded(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict forceBuffers,\n"
"#else\n"
"        __global real4* restrict forceBuffers,\n"
"#endif\n"
"        __global mixed* restrict energyBuffer, __global const real4* restrict posq, __global const unsigned int* restrict exclusions,\n"
"        __global const int2* restrict exclusionTiles, unsigned int startTileIndex, unsigned long numTileIndices\n"
"#ifdef USE_CUTOFF\n"
"        , __global const int* restrict tiles, __global const unsigned int* restrict interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, __global const real4* restrict blockCenter,\n"
"        __global const real4* restrict blockSize, __global const int* restrict interactingAtoms\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    const unsigned int totalWarps = get_global_size(0)/TILE_SIZE;\n"
"    const unsigned int warp = get_global_id(0)/TILE_SIZE;\n"
"    const unsigned int tgx = get_local_id(0) & (TILE_SIZE-1);\n"
"    const unsigned int tbx = get_local_id(0) - tgx;\n"
"    mixed energy = 0;\n"
"    INIT_DERIVATIVES\n"
"    __local AtomData localData[FORCE_WORK_GROUP_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"\n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+warp*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(warp+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/totalWarps;\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"        real4 force = 0;\n"
"        unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"        real4 posq1 = posq[atom1];\n"
"        LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_EXCLUSIONS\n"
"        unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"        const bool hasExclusions = true;\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            const unsigned int localAtomIndex = get_local_id(0);\n"
"            localData[localAtomIndex].x = posq1.x;\n"
"            localData[localAtomIndex].y = posq1.y;\n"
"            localData[localAtomIndex].z = posq1.z;\n"
"            localData[localAtomIndex].q = posq1.w;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_1\n"
"            SYNC_WARPS;\n"
"            for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+j;\n"
"                real4 posq2 = (real4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"                real invR = RSQRT(r2);\n"
"                real r = r2*invR;\n"
"                LOAD_ATOM2_PARAMETERS\n"
"                atom2 = y*TILE_SIZE+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                real dEdR = 0;\n"
"#else\n"
"                real4 dEdR1 = (real4) 0;\n"
"                real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"#endif\n"
"                real tempEnergy = 0;\n"
"                const real interactionScale = 0.5f;\n"
"                COMPUTE_INTERACTION\n"
"                energy += 0.5f*tempEnergy;\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef USE_SYMMETRIC\n"
"                force.xyz -= delta.xyz*dEdR;\n"
"#else\n"
"                force.xyz -= dEdR1.xyz;\n"
"#endif\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            const unsigned int localAtomIndex = get_local_id(0);\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"            real4 tempPosq = posq[j];\n"
"            localData[localAtomIndex].x = tempPosq.x;\n"
"            localData[localAtomIndex].y = tempPosq.y;\n"
"            localData[localAtomIndex].z = tempPosq.z;\n"
"            localData[localAtomIndex].q = tempPosq.w;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"            localData[localAtomIndex].fx = 0;\n"
"            localData[localAtomIndex].fy = 0;\n"
"            localData[localAtomIndex].fz = 0;\n"
"            SYNC_WARPS;\n"
"#ifdef USE_EXCLUSIONS\n"
"            excl = (excl >> tgx) | (excl << (TILE_SIZE - tgx));\n"
"#endif\n"
"            unsigned int tj = tgx;\n"
"            for (j = 0; j < TILE_SIZE; j++) {\n"
"                int atom2 = tbx+tj;\n"
"                real4 posq2 = (real4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                    real invR = RSQRT(r2);\n"
"                    real r = r2*invR;\n"
"                    LOAD_ATOM2_PARAMETERS\n"
"                    atom2 = y*TILE_SIZE+tj;\n"
"#ifdef USE_SYMMETRIC\n"
"                    real dEdR = 0;\n"
"#else\n"
"                    real4 dEdR1 = (real4) 0;\n"
"                    real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"#endif\n"
"                    real tempEnergy = 0;\n"
"                    const real interactionScale = 1.0f;\n"
"                    COMPUTE_INTERACTION\n"
"                    energy += tempEnergy;\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef USE_SYMMETRIC\n"
"                    delta.xyz *= dEdR;\n"
"                    force.xyz -= delta.xyz;\n"
"                    localData[tbx+tj].fx += delta.x;\n"
"                    localData[tbx+tj].fy += delta.y;\n"
"                    localData[tbx+tj].fz += delta.z;\n"
"#else\n"
"                    force.xyz -= dEdR1.xyz;\n"
"                    localData[tbx+tj].fx += dEdR2.x;\n"
"                    localData[tbx+tj].fy += dEdR2.y;\n"
"                    localData[tbx+tj].fz += dEdR2.z;\n"
"#endif\n"
"#endif\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                excl >>= 1;\n"
"#endif\n"
"                tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                SYNC_WARPS;\n"
"            }\n"
"        }\n"
"\n"
"        // Write results.\n"
"\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        unsigned int offset = x*TILE_SIZE + tgx;\n"
"        atom_add(&forceBuffers[offset], (long) (force.x*0x100000000));\n"
"        atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"        atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"        if (x != y) {\n"
"            offset = y*TILE_SIZE + tgx;\n"
"            atom_add(&forceBuffers[offset], (long) (localData[get_local_id(0)].fx*0x100000000));\n"
"            atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fy*0x100000000));\n"
"            atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fz*0x100000000));\n"
"        }\n"
"#else\n"
"        unsigned int offset1 = x*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        unsigned int offset2 = y*TILE_SIZE + tgx + warp*PADDED_NUM_ATOMS;\n"
"        forceBuffers[offset1].xyz += force.xyz;\n"
"        if (x != y)\n"
"            forceBuffers[offset2] += (real4) (localData[get_local_id(0)].fx, localData[get_local_id(0)].fy, localData[get_local_id(0)].fz, 0.0f);\n"
"#endif\n"
"#endif\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (warp*(long)numTiles/totalWarps);\n"
"    int end = (int) ((warp+1)*(long)numTiles/totalWarps);\n"
"#else\n"
"    int pos = (int) (startTileIndex+warp*numTileIndices/totalWarps);\n"
"    int end = (int) (startTileIndex+(warp+1)*numTileIndices/totalWarps);\n"
"#endif\n"
"    int skipBase = 0;\n"
"    int currentSkipIndex = tbx;\n"
"    __local int atomIndices[FORCE_WORK_GROUP_SIZE];\n"
"    __local volatile int skipTiles[FORCE_WORK_GROUP_SIZE];\n"
"    skipTiles[get_local_id(0)] = -1;\n"
"\n"
"    while (pos < end) {\n"
"        const bool hasExclusions = false;\n"
"        real4 force = 0;\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"\n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= MAX_CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= MAX_CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= MAX_CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        SYNC_WARPS;\n"
"        while (skipTiles[tbx+TILE_SIZE-1] < pos) {\n"
"            SYNC_WARPS;\n"
"            if (skipBase+tgx < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[skipBase+tgx];\n"
"                skipTiles[get_local_id(0)] = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                skipTiles[get_local_id(0)] = end;\n"
"            skipBase += TILE_SIZE;\n"
"            currentSkipIndex = tbx;\n"
"            SYNC_WARPS;\n"
"        }\n"
"        while (skipTiles[currentSkipIndex] < pos)\n"
"            currentSkipIndex++;\n"
"        includeTile = (skipTiles[currentSkipIndex] != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            unsigned int atom1 = x*TILE_SIZE + tgx;\n"
"\n"
"            // Load atom data for this tile.\n"
"\n"
"            real4 posq1 = posq[atom1];\n"
"            LOAD_ATOM1_PARAMETERS\n"
"            const unsigned int localAtomIndex = get_local_id(0);\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int j = interactingAtoms[pos*TILE_SIZE+tgx];\n"
"#else\n"
"            unsigned int j = y*TILE_SIZE + tgx;\n"
"#endif\n"
"            atomIndices[get_local_id(0)] = j;\n"
"            if (j < PADDED_NUM_ATOMS) {\n"
"                real4 tempPosq = posq[j];\n"
"                localData[localAtomIndex].x = tempPosq.x;\n"
"                localData[localAtomIndex].y = tempPosq.y;\n"
"                localData[localAtomIndex].z = tempPosq.z;\n"
"                localData[localAtomIndex].q = tempPosq.w;\n"
"                LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                localData[localAtomIndex].fx = 0;\n"
"                localData[localAtomIndex].fy = 0;\n"
"                localData[localAtomIndex].fz = 0;\n"
"            }\n"
"            else {\n"
"                localData[localAtomIndex].x = 0;\n"
"                localData[localAtomIndex].y = 0;\n"
"                localData[localAtomIndex].z = 0;\n"
"                CLEAR_LOCAL_PARAMETERS\n"
"            }\n"
"            SYNC_WARPS;\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(posq1, blockCenterX)\n"
"                APPLY_PERIODIC_TO_POS_WITH_CENTER(localData[localAtomIndex], blockCenterX)\n"
"                SYNC_WARPS;\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"                    real4 posq2 = (real4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                    real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                    if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = atomIndices[tbx+tj];\n"
"#ifdef USE_SYMMETRIC\n"
"                        real dEdR = 0;\n"
"#else\n"
"                        real4 dEdR1 = (real4) 0;\n"
"                        real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS);\n"
"#endif\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 1.0f;\n"
"                        COMPUTE_INTERACTION\n"
"                        energy += tempEnergy;\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef USE_SYMMETRIC\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"                        localData[tbx+tj].fx += delta.x;\n"
"                        localData[tbx+tj].fy += delta.y;\n"
"                        localData[tbx+tj].fz += delta.z;\n"
"#else\n"
"                        force.xyz -= dEdR1.xyz;\n"
"                        localData[tbx+tj].fx += dEdR2.x;\n"
"                        localData[tbx+tj].fy += dEdR2.y;\n"
"                        localData[tbx+tj].fz += dEdR2.z;\n"
"#endif\n"
"#endif\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                    }\n"
"#endif\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                unsigned int tj = tgx;\n"
"                for (j = 0; j < TILE_SIZE; j++) {\n"
"                    int atom2 = tbx+tj;\n"
"                    real4 posq2 = (real4) (localData[atom2].x, localData[atom2].y, localData[atom2].z, localData[atom2].q);\n"
"                    real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                    if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = atomIndices[tbx+tj];\n"
"#ifdef USE_SYMMETRIC\n"
"                        real dEdR = 0;\n"
"#else\n"
"                        real4 dEdR1 = (real4) 0;\n"
"                        real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS);\n"
"#endif\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 1.0f;\n"
"                        COMPUTE_INTERACTION\n"
"                        energy += tempEnergy;\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef USE_SYMMETRIC\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"                        localData[tbx+tj].fx += delta.x;\n"
"                        localData[tbx+tj].fy += delta.y;\n"
"                        localData[tbx+tj].fz += delta.z;\n"
"#else\n"
"                        force.xyz -= dEdR1.xyz;\n"
"                        localData[tbx+tj].fx += dEdR2.x;\n"
"                        localData[tbx+tj].fy += dEdR2.y;\n"
"                        localData[tbx+tj].fz += dEdR2.z;\n"
"#endif\n"
"#endif\n"
"#ifdef PRUNE_BY_CUTOFF\n"
"                    }\n"
"#endif\n"
"                    tj = (tj + 1) & (TILE_SIZE - 1);\n"
"                    SYNC_WARPS;\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"#ifdef INCLUDE_FORCES\n"
"#ifdef USE_CUTOFF\n"
"            unsigned int atom2 = atomIndices[get_local_id(0)];\n"
"#else\n"
"            unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"            atom_add(&forceBuffers[atom1], (long) (force.x*0x100000000));\n"
"            atom_add(&forceBuffers[atom1+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"            atom_add(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"            if (atom2 < PADDED_NUM_ATOMS) {\n"
"                atom_add(&forceBuffers[atom2], (long) (localData[get_local_id(0)].fx*0x100000000));\n"
"                atom_add(&forceBuffers[atom2+PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fy*0x100000000));\n"
"                atom_add(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (long) (localData[get_local_id(0)].fz*0x100000000));\n"
"            }\n"
"#else\n"
"            unsigned int offset1 = atom1 + warp*PADDED_NUM_ATOMS;\n"
"            unsigned int offset2 = atom2 + warp*PADDED_NUM_ATOMS;\n"
"            forceBuffers[offset1].xyz += force.xyz;\n"
"            if (atom2 < PADDED_NUM_ATOMS)\n"
"                forceBuffers[offset2] += (real4) (localData[get_local_id(0)].fx, localData[get_local_id(0)].fy, localData[get_local_id(0)].fz, 0.0f);\n"
"#endif\n"
"#endif\n"
"        }\n"
"        pos++;\n"
"    }\n"
"#ifdef INCLUDE_ENERGY\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"#endif\n"
"    SAVE_DERIVATIVES\n"
"}\n"
"";
const string OpenCLKernelSources::nonbondedExceptions = "float4 exceptionParams = PARAMS[index];\n"
"real4 delta = pos2-pos1;\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"real invR = RSQRT(r2);\n"
"real sig2 = invR*exceptionParams.y;\n"
"sig2 *= sig2;\n"
"real sig6 = sig2*sig2*sig2;\n"
"real dEdR = exceptionParams.z*(12.0f*sig6-6.0f)*sig6;\n"
"real tempEnergy = exceptionParams.z*(sig6-1.0f)*sig6;\n"
"dEdR += exceptionParams.x*invR;\n"
"dEdR *= invR*invR;\n"
"tempEnergy += exceptionParams.x*invR;\n"
"energy += tempEnergy;\n"
"delta.xyz *= dEdR;\n"
"real4 force1 = -delta;\n"
"real4 force2 = delta;\n"
"";
const string OpenCLKernelSources::nonbondedParameters = "/**\n"
" * Compute the nonbonded parameters for particles and exceptions.\n"
" */\n"
"__kernel void computeParameters(__global mixed* restrict energyBuffer, int includeSelfEnergy, __global real* restrict globalParams,\n"
"        int numAtoms, __global const float4* restrict baseParticleParams, __global real4* restrict posq, __global real* restrict charge,\n"
"        __global float2* restrict sigmaEpsilon, __global float4* restrict particleParamOffsets, __global int* restrict particleOffsetIndices\n"
"#ifdef HAS_EXCEPTIONS\n"
"        , int numExceptions, __global const float4* restrict baseExceptionParams, __global float4* restrict exceptionParams,\n"
"        __global float4* restrict exceptionParamOffsets, __global int* restrict exceptionOffsetIndices\n"
"#endif\n"
"        ) {\n"
"    mixed energy = 0;\n"
"\n"
"    // Compute particle parameters.\n"
"    \n"
"    for (int i = get_global_id(0); i < numAtoms; i += get_global_size(0)) {\n"
"        float4 params = baseParticleParams[i];\n"
"#ifdef HAS_OFFSETS\n"
"        int start = particleOffsetIndices[i], end = particleOffsetIndices[i+1];\n"
"        for (int j = start; j < end; j++) {\n"
"            float4 offset = particleParamOffsets[j];\n"
"            real value = globalParams[(int) offset.w];\n"
"            params.x += value*offset.x;\n"
"            params.y += value*offset.y;\n"
"            params.z += value*offset.z;\n"
"        }\n"
"#endif\n"
"#ifdef USE_POSQ_CHARGES\n"
"        posq[i].w = params.x;\n"
"#else\n"
"        charge[i] = params.x;\n"
"#endif\n"
"        sigmaEpsilon[i] = (float2) (0.5f*params.y, 2*SQRT(params.z));\n"
"#ifdef HAS_OFFSETS\n"
"    #ifdef INCLUDE_EWALD\n"
"        energy -= EWALD_SELF_ENERGY_SCALE*params.x*params.x;\n"
"    #endif\n"
"    #ifdef INCLUDE_LJPME\n"
"        real sig3 = params.y*params.y*params.y;\n"
"        energy += LJPME_SELF_ENERGY_SCALE*sig3*sig3*params.z;\n"
"    #endif\n"
"#endif\n"
"    }\n"
"\n"
"    // Compute exception parameters.\n"
"    \n"
"#ifdef HAS_EXCEPTIONS\n"
"    for (int i = get_global_id(0); i < numExceptions; i += get_global_size(0)) {\n"
"        float4 params = baseExceptionParams[i];\n"
"#ifdef HAS_OFFSETS\n"
"        int start = exceptionOffsetIndices[i], end = exceptionOffsetIndices[i+1];\n"
"        for (int j = start; j < end; j++) {\n"
"            float4 offset = exceptionParamOffsets[j];\n"
"            real value = globalParams[(int) offset.w];\n"
"            params.x += value*offset.x;\n"
"            params.y += value*offset.y;\n"
"            params.z += value*offset.z;\n"
"        }\n"
"#endif\n"
"        exceptionParams[i] = (float4) ((float) (ONE_4PI_EPS0*params.x), (float) params.y, (float) (4*params.z), 0);\n"
"    }\n"
"#endif\n"
"    if (includeSelfEnergy)\n"
"        energyBuffer[get_global_id(0)] += energy;\n"
"}\n"
"\n"
"/**\n"
" * Compute parameters for subtracting the reciprocal part of excluded interactions.\n"
" */\n"
"__kernel void computeExclusionParameters(__global real4* restrict posq, __global real* restrict charge, __global float2* restrict sigmaEpsilon,\n"
"        int numExclusions, __global const int2* restrict exclusionAtoms, __global float4* restrict exclusionParams) {\n"
"    for (int i = get_global_id(0); i < numExclusions; i += get_global_size(0)) {\n"
"        int2 atoms = exclusionAtoms[i];\n"
"#ifdef USE_POSQ_CHARGES\n"
"        real chargeProd = posq[atoms.x].w*posq[atoms.y].w;\n"
"#else\n"
"        real chargeProd = charge[atoms.x]*charge[atoms.y];\n"
"#endif\n"
"#ifdef INCLUDE_LJPME\n"
"        float2 sigEps1 = sigmaEpsilon[atoms.x];\n"
"        float2 sigEps2 = sigmaEpsilon[atoms.y];\n"
"        float sigma = sigEps1.x*sigEps2.x;\n"
"        float epsilon = sigEps1.y*sigEps2.y;\n"
"#else\n"
"        float sigma = 0;\n"
"        float epsilon = 0;\n"
"#endif\n"
"        exclusionParams[i] = (float4) ((float) (ONE_4PI_EPS0*chargeProd), sigma, epsilon, 0);\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::nonbonded_cpu = "#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"#endif\n"
"\n"
"typedef struct {\n"
"    real x, y, z;\n"
"    real q;\n"
"    real fx, fy, fz;\n"
"    ATOM_PARAMETER_DATA\n"
"} AtomData;\n"
"\n"
"/**\n"
" * Compute nonbonded interactions.\n"
" */\n"
"\n"
"__kernel void computeNonbonded(\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        __global long* restrict forceBuffers,\n"
"#else\n"
"        __global real4* restrict forceBuffers,\n"
"#endif\n"
"        __global mixed* restrict energyBuffer, __global const real4* restrict posq, __global const unsigned int* restrict exclusions,\n"
"        __global const int2* restrict exclusionTiles, unsigned int startTileIndex, unsigned long numTileIndices\n"
"#ifdef USE_CUTOFF\n"
"        , __global const int* restrict tiles, __global const unsigned int* restrict interactionCount, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, unsigned int maxTiles, __global const real4* restrict blockCenter,\n"
"        __global const real4* restrict blockSize, __global const int* restrict interactingAtoms\n"
"#endif\n"
"        PARAMETER_ARGUMENTS) {\n"
"    mixed energy = 0;\n"
"    INIT_DERIVATIVES\n"
"    __local AtomData localData[TILE_SIZE];\n"
"\n"
"    // First loop: process tiles that contain exclusions.\n"
"\n"
"    const unsigned int firstExclusionTile = FIRST_EXCLUSION_TILE+get_group_id(0)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/get_num_groups(0);\n"
"    const unsigned int lastExclusionTile = FIRST_EXCLUSION_TILE+(get_group_id(0)+1)*(LAST_EXCLUSION_TILE-FIRST_EXCLUSION_TILE)/get_num_groups(0);\n"
"    for (int pos = firstExclusionTile; pos < lastExclusionTile; pos++) {\n"
"        const int2 tileIndices = exclusionTiles[pos];\n"
"        const unsigned int x = tileIndices.x;\n"
"        const unsigned int y = tileIndices.y;\n"
"\n"
"        // Load the data for this tile.\n"
"\n"
"        for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"            unsigned int j = y*TILE_SIZE + localAtomIndex;\n"
"            real4 tempPosq = posq[j];\n"
"            localData[localAtomIndex].x = tempPosq.x;\n"
"            localData[localAtomIndex].y = tempPosq.y;\n"
"            localData[localAtomIndex].z = tempPosq.z;\n"
"            localData[localAtomIndex].q = tempPosq.w;\n"
"            LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"        }\n"
"        const bool hasExclusions = true;\n"
"        if (x == y) {\n"
"            // This tile is on the diagonal.\n"
"\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real4 force = 0;\n"
"                real4 posq1 = posq[atom1];\n"
"                LOAD_ATOM1_PARAMETERS\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real4 posq2 = (real4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                    real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                        real dEdR = 0;\n"
"#else\n"
"                        real4 dEdR1 = (real4) 0;\n"
"                        real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"#endif\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 0.5f;\n"
"                        COMPUTE_INTERACTION\n"
"                        energy += 0.5f*tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                        force.xyz -= delta.xyz*dEdR;\n"
"#else\n"
"                        force.xyz -= dEdR1.xyz;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"\n"
"                // Write results.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                atom_add(&forceBuffers[atom1], (long) (force.x*0x100000000));\n"
"                atom_add(&forceBuffers[atom1+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"                atom_add(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"#else\n"
"                unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"#endif\n"
"            }\n"
"        }\n"
"        else {\n"
"            // This is an off-diagonal tile.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                localData[tgx].fx = 0;\n"
"                localData[tgx].fy = 0;\n"
"                localData[tgx].fz = 0;\n"
"            }\n"
"            for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                real4 force = 0;\n"
"                real4 posq1 = posq[atom1];\n"
"                LOAD_ATOM1_PARAMETERS\n"
"#ifdef USE_EXCLUSIONS\n"
"                unsigned int excl = exclusions[pos*TILE_SIZE+tgx];\n"
"#endif\n"
"                for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                    real4 posq2 = (real4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                    real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                    real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                    if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                        real invR = RSQRT(r2);\n"
"                        real r = r2*invR;\n"
"                        unsigned int atom2 = j;\n"
"                        LOAD_ATOM2_PARAMETERS\n"
"                        atom2 = y*TILE_SIZE+j;\n"
"#ifdef USE_SYMMETRIC\n"
"                        real dEdR = 0;\n"
"#else\n"
"                        real4 dEdR1 = (real4) 0;\n"
"                        real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                        bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS || !(excl & 0x1));\n"
"#endif\n"
"                        real tempEnergy = 0;\n"
"                        const real interactionScale = 1.0f;\n"
"                        COMPUTE_INTERACTION\n"
"                        energy += tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                        delta.xyz *= dEdR;\n"
"                        force.xyz -= delta.xyz;\n"
"                        localData[j].fx += delta.x;\n"
"                        localData[j].fy += delta.y;\n"
"                        localData[j].fz += delta.z;\n"
"#else\n"
"                        force.xyz -= dEdR1.xyz;\n"
"                        localData[j].fx += dEdR2.x;\n"
"                        localData[j].fy += dEdR2.y;\n"
"                        localData[j].fz += dEdR2.z;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"                    }\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                    excl >>= 1;\n"
"#endif\n"
"                }\n"
"\n"
"               // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                atom_add(&forceBuffers[atom1], (long) (force.x*0x100000000));\n"
"                atom_add(&forceBuffers[atom1+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"                atom_add(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"#else\n"
"                unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"#endif\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                unsigned int offset = y*TILE_SIZE + tgx;\n"
"                atom_add(&forceBuffers[offset], (long) (localData[tgx].fx*0x100000000));\n"
"                atom_add(&forceBuffers[offset+PADDED_NUM_ATOMS], (long) (localData[tgx].fy*0x100000000));\n"
"                atom_add(&forceBuffers[offset+2*PADDED_NUM_ATOMS], (long) (localData[tgx].fz*0x100000000));\n"
"#else\n"
"                unsigned int offset = y*TILE_SIZE+tgx + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                real4 f = forceBuffers[offset];\n"
"                f.x += localData[tgx].fx;\n"
"                f.y += localData[tgx].fy;\n"
"                f.z += localData[tgx].fz;\n"
"                forceBuffers[offset] = f;\n"
"#endif\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    // Second loop: tiles without exclusions, either from the neighbor list (with cutoff) or just enumerating all\n"
"    // of them (no cutoff).\n"
"\n"
"#ifdef USE_CUTOFF\n"
"    const unsigned int numTiles = interactionCount[0];\n"
"    if (numTiles > maxTiles)\n"
"        return; // There wasn't enough memory for the neighbor list.\n"
"    int pos = (int) (numTiles > maxTiles ? (unsigned int) (startTileIndex+get_group_id(0)*(long)numTileIndices/get_num_groups(0)) : get_group_id(0)*(long)numTiles/get_num_groups(0));\n"
"    int end = (int) (numTiles > maxTiles ? (unsigned int) (startTileIndex+(get_group_id(0)+1)*(long)numTileIndices/get_num_groups(0)) : (get_group_id(0)+1)*(long)numTiles/get_num_groups(0));\n"
"#else\n"
"    const unsigned int numTiles = numTileIndices;\n"
"    int pos = (int) (startTileIndex+get_group_id(0)*(long)numTiles/get_num_groups(0));\n"
"    int end = (int) (startTileIndex+(get_group_id(0)+1)*(long)numTiles/get_num_groups(0));\n"
"#endif\n"
"    int nextToSkip = -1;\n"
"    int currentSkipIndex = 0;\n"
"    __local int atomIndices[TILE_SIZE];\n"
"\n"
"    while (pos < end) {\n"
"        const bool hasExclusions = false;\n"
"        bool includeTile = true;\n"
"\n"
"        // Extract the coordinates of this tile.\n"
"\n"
"        int x, y;\n"
"        bool singlePeriodicCopy = false;\n"
"#ifdef USE_CUTOFF\n"
"        x = tiles[pos];\n"
"        real4 blockSizeX = blockSize[x];\n"
"        singlePeriodicCopy = (0.5f*periodicBoxSize.x-blockSizeX.x >= MAX_CUTOFF &&\n"
"                              0.5f*periodicBoxSize.y-blockSizeX.y >= MAX_CUTOFF &&\n"
"                              0.5f*periodicBoxSize.z-blockSizeX.z >= MAX_CUTOFF);\n"
"#else\n"
"        y = (int) floor(NUM_BLOCKS+0.5f-SQRT((NUM_BLOCKS+0.5f)*(NUM_BLOCKS+0.5f)-2*pos));\n"
"        x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        if (x < y || x >= NUM_BLOCKS) { // Occasionally happens due to roundoff error.\n"
"            y += (x < y ? -1 : 1);\n"
"            x = (pos-y*NUM_BLOCKS+y*(y+1)/2);\n"
"        }\n"
"\n"
"        // Skip over tiles that have exclusions, since they were already processed.\n"
"\n"
"        while (nextToSkip < pos) {\n"
"            if (currentSkipIndex < NUM_TILES_WITH_EXCLUSIONS) {\n"
"                int2 tile = exclusionTiles[currentSkipIndex++];\n"
"                nextToSkip = tile.x + tile.y*NUM_BLOCKS - tile.y*(tile.y+1)/2;\n"
"            }\n"
"            else\n"
"                nextToSkip = end;\n"
"        }\n"
"        includeTile = (nextToSkip != pos);\n"
"#endif\n"
"        if (includeTile) {\n"
"            // Load the data for this tile.\n"
"\n"
"            for (int localAtomIndex = 0; localAtomIndex < TILE_SIZE; localAtomIndex++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int j = interactingAtoms[pos*TILE_SIZE+localAtomIndex];\n"
"#else\n"
"                unsigned int j = y*TILE_SIZE+localAtomIndex;\n"
"#endif\n"
"                atomIndices[localAtomIndex] = j;\n"
"                if (j < PADDED_NUM_ATOMS) {\n"
"                    real4 tempPosq = posq[j];\n"
"                    localData[localAtomIndex].x = tempPosq.x;\n"
"                    localData[localAtomIndex].y = tempPosq.y;\n"
"                    localData[localAtomIndex].z = tempPosq.z;\n"
"                    localData[localAtomIndex].q = tempPosq.w;\n"
"                    LOAD_LOCAL_PARAMETERS_FROM_GLOBAL\n"
"                    localData[localAtomIndex].fx = 0;\n"
"                    localData[localAtomIndex].fy = 0;\n"
"                    localData[localAtomIndex].fz = 0;\n"
"                }\n"
"            }\n"
"#ifdef USE_PERIODIC\n"
"            if (singlePeriodicCopy) {\n"
"                // The box is small enough that we can just translate all the atoms into a single periodic\n"
"                // box, then skip having to apply periodic boundary conditions later.\n"
"\n"
"                real4 blockCenterX = blockCenter[x];\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(localData[tgx], blockCenterX)\n"
"                }\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real4 force = 0;\n"
"                    real4 posq1 = posq[atom1];\n"
"                    APPLY_PERIODIC_TO_POS_WITH_CENTER(posq1, blockCenterX)\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real4 posq2 = (real4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                        real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"                        real r2 = dot(delta.xyz, delta.xyz);\n"
"                        if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            unsigned int atom2 = j;\n"
"                            LOAD_ATOM2_PARAMETERS\n"
"                            atom2 = atomIndices[j];\n"
"#ifdef USE_SYMMETRIC\n"
"                            real dEdR = 0;\n"
"#else\n"
"                            real4 dEdR1 = (real4) 0;\n"
"                            real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                            bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS);\n"
"#endif\n"
"                            real tempEnergy = 0;\n"
"                            const real interactionScale = 1.0f;\n"
"                            COMPUTE_INTERACTION\n"
"                            energy += tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                            delta.xyz *= dEdR;\n"
"                            force.xyz -= delta.xyz;\n"
"                            localData[j].fx += delta.x;\n"
"                            localData[j].fy += delta.y;\n"
"                            localData[j].fz += delta.z;\n"
"#else\n"
"                            force.xyz -= dEdR1.xyz;\n"
"                            localData[j].fx += dEdR2.x;\n"
"                            localData[j].fy += dEdR2.y;\n"
"                            localData[j].fz += dEdR2.z;\n"
"#endif\n"
"                        }\n"
"                    }\n"
"\n"
"                   // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    atom_add(&forceBuffers[atom1], (long) (force.x*0x100000000));\n"
"                    atom_add(&forceBuffers[atom1+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"                    atom_add(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"#endif\n"
"                }\n"
"            }\n"
"            else\n"
"#endif\n"
"            {\n"
"                // We need to apply periodic boundary conditions separately for each interaction.\n"
"\n"
"                for (unsigned int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"                    unsigned int atom1 = x*TILE_SIZE+tgx;\n"
"                    real4 force = 0;\n"
"                    real4 posq1 = posq[atom1];\n"
"                    LOAD_ATOM1_PARAMETERS\n"
"                    for (unsigned int j = 0; j < TILE_SIZE; j++) {\n"
"                        real4 posq2 = (real4) (localData[j].x, localData[j].y, localData[j].z, localData[j].q);\n"
"                        real4 delta = (real4) (posq2.xyz - posq1.xyz, 0);\n"
"#ifdef USE_PERIODIC\n"
"                        APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"                        real r2 = dot(delta.xyz, delta.xyz);\n"
"#ifdef USE_CUTOFF\n"
"                        if (r2 < MAX_CUTOFF*MAX_CUTOFF) {\n"
"#endif\n"
"                            real invR = RSQRT(r2);\n"
"                            real r = r2*invR;\n"
"                            unsigned int atom2 = j;\n"
"                            LOAD_ATOM2_PARAMETERS\n"
"                            atom2 = atomIndices[j];\n"
"#ifdef USE_SYMMETRIC\n"
"                            real dEdR = 0;\n"
"#else\n"
"                            real4 dEdR1 = (real4) 0;\n"
"                            real4 dEdR2 = (real4) 0;\n"
"#endif\n"
"#ifdef USE_EXCLUSIONS\n"
"                            bool isExcluded = (atom1 >= NUM_ATOMS || atom2 >= NUM_ATOMS);\n"
"#endif\n"
"                            real tempEnergy = 0;\n"
"                            const real interactionScale = 1.0f;\n"
"                            COMPUTE_INTERACTION\n"
"                            energy += tempEnergy;\n"
"#ifdef USE_SYMMETRIC\n"
"                            delta.xyz *= dEdR;\n"
"                            force.xyz -= delta.xyz;\n"
"                            localData[j].fx += delta.x;\n"
"                            localData[j].fy += delta.y;\n"
"                            localData[j].fz += delta.z;\n"
"#else\n"
"                            force.xyz -= dEdR1.xyz;\n"
"                            localData[j].fx += dEdR2.x;\n"
"                            localData[j].fy += dEdR2.y;\n"
"                            localData[j].fz += dEdR2.z;\n"
"#endif\n"
"#ifdef USE_CUTOFF\n"
"                        }\n"
"#endif\n"
"                    }\n"
"\n"
"                    // Write results for atom1.\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    atom_add(&forceBuffers[atom1], (long) (force.x*0x100000000));\n"
"                    atom_add(&forceBuffers[atom1+PADDED_NUM_ATOMS], (long) (force.y*0x100000000));\n"
"                    atom_add(&forceBuffers[atom1+2*PADDED_NUM_ATOMS], (long) (force.z*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom1 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    forceBuffers[offset].xyz = forceBuffers[offset].xyz+force.xyz;\n"
"#endif\n"
"                }\n"
"            }\n"
"\n"
"            // Write results.\n"
"\n"
"            for (int tgx = 0; tgx < TILE_SIZE; tgx++) {\n"
"#ifdef USE_CUTOFF\n"
"                unsigned int atom2 = atomIndices[tgx];\n"
"#else\n"
"                unsigned int atom2 = y*TILE_SIZE + tgx;\n"
"#endif\n"
"                if (atom2 < PADDED_NUM_ATOMS) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"                    atom_add(&forceBuffers[atom2], (long) (localData[tgx].fx*0x100000000));\n"
"                    atom_add(&forceBuffers[atom2+PADDED_NUM_ATOMS], (long) (localData[tgx].fy*0x100000000));\n"
"                    atom_add(&forceBuffers[atom2+2*PADDED_NUM_ATOMS], (long) (localData[tgx].fz*0x100000000));\n"
"#else\n"
"                    unsigned int offset = atom2 + get_group_id(0)*PADDED_NUM_ATOMS;\n"
"                    real4 f = forceBuffers[offset];\n"
"                    f.x += localData[tgx].fx;\n"
"                    f.y += localData[tgx].fy;\n"
"                    f.z += localData[tgx].fz;\n"
"                    forceBuffers[offset] = f;\n"
"#endif\n"
"                }\n"
"            }\n"
"        }\n"
"        pos++;\n"
"    }\n"
"    energyBuffer[get_global_id(0)] += energy;\n"
"    SAVE_DERIVATIVES\n"
"}\n"
"";
const string OpenCLKernelSources::pme = "__kernel void updateBsplines(__global const real4* restrict posq, __global real4* restrict pmeBsplineTheta, __local real4* restrict bsplinesCache,\n"
"        __global int2* restrict pmeAtomGridIndex, real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ,\n"
"        real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ\n"
"#ifdef USE_LJPME\n"
"        , __global const float2* restrict sigmaEpsilon\n"
"#else\n"
"        , __global const real* restrict charges\n"
"#endif\n"
"    ) {\n"
"    const real4 scale = 1/(real) (PME_ORDER-1);\n"
"    for (int atom = get_global_id(0); atom < NUM_ATOMS; atom += get_global_size(0)) {\n"
"        __local real4* data = &bsplinesCache[get_local_id(0)*PME_ORDER];\n"
"        real4 pos = posq[atom];\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"        real3 t = (real3) (pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x,\n"
"                           pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y,\n"
"                           pos.z*recipBoxVecZ.z);\n"
"        t.x = (t.x-floor(t.x))*GRID_SIZE_X;\n"
"        t.y = (t.y-floor(t.y))*GRID_SIZE_Y;\n"
"        t.z = (t.z-floor(t.z))*GRID_SIZE_Z;\n"
"        real4 dr = (real4) (t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z, 0.0f);\n"
"        int4 gridIndex = (int4) (((int) t.x) % GRID_SIZE_X,\n"
"                                 ((int) t.y) % GRID_SIZE_Y,\n"
"                                 ((int) t.z) % GRID_SIZE_Z, 0);\n"
"        pmeAtomGridIndex[atom] = (int2) (atom, gridIndex.x*GRID_SIZE_Y*GRID_SIZE_Z+gridIndex.y*GRID_SIZE_Z+gridIndex.z);\n"
"#ifndef SUPPORTS_64_BIT_ATOMICS\n"
"        data[PME_ORDER-1] = 0.0f;\n"
"        data[1] = dr;\n"
"        data[0] = 1.0f-dr;\n"
"        for (int j = 3; j < PME_ORDER; j++) {\n"
"            real div = RECIP(j-1.0f);\n"
"            data[j-1] = div*dr*data[j-2];\n"
"            for (int k = 1; k < (j-1); k++)\n"
"                data[j-k-1] = div*((dr+(real4) k) *data[j-k-2] + (-dr+(real4) (j-k))*data[j-k-1]);\n"
"            data[0] = div*(- dr+1.0f)*data[0];\n"
"        }\n"
"        data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"        for (int j = 1; j < (PME_ORDER-1); j++)\n"
"            data[PME_ORDER-j-1] = scale*((dr+(real4) j)*data[PME_ORDER-j-2] + (-dr+(real4) (PME_ORDER-j))*data[PME_ORDER-j-1]);\n"
"        data[0] = scale*(-dr+1.0f)*data[0];\n"
"        for (int j = 0; j < PME_ORDER; j++) {\n"
"#ifdef USE_LJPME\n"
"            const float2 sigEps = sigmaEpsilon[atom];\n"
"            const real charge = 8*sigEps.x*sigEps.x*sigEps.x*sigEps.y;\n"
"#else\n"
"            const real charge = CHARGE;\n"
"#endif\n"
"            data[j].w = charge; // Storing the charge here improves cache coherency in the charge spreading kernel\n"
"            pmeBsplineTheta[atom+j*NUM_ATOMS] = data[j];\n"
"        }\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * For each grid point, find the range of sorted atoms associated with that point.\n"
" */\n"
"__kernel void findAtomRangeForGrid(__global int2* restrict pmeAtomGridIndex, __global int* restrict pmeAtomRange, __global const real4* restrict posq) {\n"
"    int start = (NUM_ATOMS*get_global_id(0))/get_global_size(0);\n"
"    int end = (NUM_ATOMS*(get_global_id(0)+1))/get_global_size(0);\n"
"    int last = (start == 0 ? -1 : pmeAtomGridIndex[start-1].y);\n"
"    for (int i = start; i < end; ++i) {\n"
"        int2 atomData = pmeAtomGridIndex[i];\n"
"        int gridIndex = atomData.y;\n"
"        if (gridIndex != last) {\n"
"            for (int j = last+1; j <= gridIndex; ++j)\n"
"                pmeAtomRange[j] = i;\n"
"            last = gridIndex;\n"
"        }\n"
"    }\n"
"\n"
"    // Fill in values beyond the last atom.\n"
"\n"
"    if (get_global_id(0) == get_global_size(0)-1) {\n"
"        int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"        for (int j = last+1; j <= gridSize; ++j)\n"
"            pmeAtomRange[j] = NUM_ATOMS;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * The grid index won't be needed again.  Reuse that component to hold the z index, thus saving\n"
" * some work in the charge spreading kernel.\n"
" */\n"
"__kernel void recordZIndex(__global int2* restrict pmeAtomGridIndex, __global const real4* restrict posq, real4 periodicBoxSize, real4 recipBoxVecZ) {\n"
"    int start = (NUM_ATOMS*get_global_id(0))/get_global_size(0);\n"
"    int end = (NUM_ATOMS*(get_global_id(0)+1))/get_global_size(0);\n"
"    for (int i = start; i < end; ++i) {\n"
"        real posz = posq[pmeAtomGridIndex[i].x].z;\n"
"        posz -= floor(posz*recipBoxVecZ.z)*periodicBoxSize.z;\n"
"        int z = ((int) ((posz*recipBoxVecZ.z)*GRID_SIZE_Z)) % GRID_SIZE_Z;\n"
"        pmeAtomGridIndex[i].y = z;\n"
"    }\n"
"}\n"
"\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
"\n"
"__kernel void gridSpreadCharge(__global const real4* restrict posq, __global const int2* restrict pmeAtomGridIndex, __global const int* restrict pmeAtomRange,\n"
"        __global long* restrict pmeGrid, __global const real4* restrict pmeBsplineTheta, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ\n"
"#ifdef USE_LJPME\n"
"        , __global const float2* restrict sigmaEpsilon\n"
"#else\n"
"        , __global const real* restrict charges\n"
"#endif\n"
"    ) {\n"
"    // To improve memory efficiency, we divide indices along the z axis into\n"
"    // PME_ORDER blocks, where the data for each block is stored together.  We\n"
"    // can ensure that all threads write to the same block at the same time,\n"
"    // which leads to better coalescing of writes.\n"
"    \n"
"    __local int zindexTable[GRID_SIZE_Z+PME_ORDER];\n"
"    int blockSize = (int) ceil(GRID_SIZE_Z/(real) PME_ORDER);\n"
"    for (int i = get_local_id(0); i < GRID_SIZE_Z+PME_ORDER; i += get_local_size(0)) {\n"
"        int zindex = i % GRID_SIZE_Z;\n"
"	int block = zindex % PME_ORDER;\n"
"        zindexTable[i] = zindex/PME_ORDER + block*GRID_SIZE_X*GRID_SIZE_Y*blockSize;\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"        \n"
"    // Process the atoms in spatially sorted order.  This improves efficiency when writing\n"
"    // the grid values.\n"
"    \n"
"    const real scale = 1/(real) (PME_ORDER-1);\n"
"    real4 data[PME_ORDER];\n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0)) {\n"
"        int atom = pmeAtomGridIndex[i].x;\n"
"        real4 pos = posq[atom];\n"
"#ifdef USE_LJPME\n"
"        const float2 sigEps = sigmaEpsilon[atom];\n"
"        const real charge = 8*sigEps.x*sigEps.x*sigEps.x*sigEps.y;\n"
"#else\n"
"        const real charge = (CHARGE)*EPSILON_FACTOR;\n"
"#endif\n"
"        if (charge == 0)\n"
"            continue;\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"        real3 t = (real3) (pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x,\n"
"                           pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y,\n"
"                           pos.z*recipBoxVecZ.z);\n"
"        t.x = (t.x-floor(t.x))*GRID_SIZE_X;\n"
"        t.y = (t.y-floor(t.y))*GRID_SIZE_Y;\n"
"        t.z = (t.z-floor(t.z))*GRID_SIZE_Z;\n"
"        int4 gridIndex = (int4) (((int) t.x) % GRID_SIZE_X,\n"
"                                 ((int) t.y) % GRID_SIZE_Y,\n"
"                                 ((int) t.z) % GRID_SIZE_Z, 0);\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real4 dr = (real4) (t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z, 0.0f);\n"
"        data[PME_ORDER-1] = 0.0f;\n"
"        data[1] = dr;\n"
"        data[0] = 1.0f-dr;\n"
"        for (int j = 3; j < PME_ORDER; j++) {\n"
"            real div = RECIP(j-1.0f);\n"
"            data[j-1] = div*dr*data[j-2];\n"
"            for (int k = 1; k < (j-1); k++)\n"
"                data[j-k-1] = div*((dr+(real4) k) *data[j-k-2] + (-dr+(real4) (j-k))*data[j-k-1]);\n"
"            data[0] = div*(-dr+1.0f)*data[0];\n"
"        }\n"
"        data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"        for (int j = 1; j < (PME_ORDER-1); j++)\n"
"            data[PME_ORDER-j-1] = scale*((dr+(real4) j)*data[PME_ORDER-j-2] + (-dr+(real4) (PME_ORDER-j))*data[PME_ORDER-j-1]);\n"
"        data[0] = scale*(-dr+1.0f)*data[0];\n"
"\n"
"        // Spread the charge from this atom onto each grid point.\n"
"\n"
"	int izoffset = (PME_ORDER-(gridIndex.z%PME_ORDER)) % PME_ORDER;\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xbase = gridIndex.x+ix;\n"
"            xbase -= (xbase >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            xbase = xbase*GRID_SIZE_Y;\n"
"            real dx = charge*data[ix].x;\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int ybase = gridIndex.y+iy;\n"
"                ybase -= (ybase >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                ybase = (xbase+ybase)*blockSize;\n"
"                real dxdy = dx*data[iy].y;\n"
"                for (int i = 0; i < PME_ORDER; i++) {\n"
"		    int iz = (i+izoffset) % PME_ORDER;\n"
"                    int zindex = gridIndex.z+iz;\n"
"                    int index = ybase + zindexTable[zindex];\n"
"                    real add = dxdy*data[iz].z;\n"
"                    atom_add(&pmeGrid[index], (long) (add*0x100000000));\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"__kernel void finishSpreadCharge(__global long* restrict grid1, __global real* restrict grid2) {\n"
"    // During charge spreading, we shuffled the order of indices along the z\n"
"    // axis to make memory access more efficient.  We now need to unshuffle\n"
"    // them and convert fixed point values to floating point.\n"
"\n"
"    __local int zindexTable[GRID_SIZE_Z];\n"
"    int blockSize = (int) ceil(GRID_SIZE_Z/(real) PME_ORDER);\n"
"    for (int i = get_local_id(0); i < GRID_SIZE_Z; i += get_local_size(0)) {\n"
"	int block = i % PME_ORDER;\n"
"        zindexTable[i] = i/PME_ORDER + block*GRID_SIZE_X*GRID_SIZE_Y*blockSize;\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"    real scale = 1/(real) 0x100000000;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        int zindex = index%GRID_SIZE_Z;\n"
"        int loadIndex = zindexTable[zindex] + blockSize*(int) (index/GRID_SIZE_Z);\n"
"        grid2[index] = scale*grid1[loadIndex];\n"
"    }\n"
"}\n"
"#elif defined(DEVICE_IS_CPU)\n"
"__kernel void gridSpreadCharge(__global const real4* restrict posq, __global const int2* restrict pmeAtomGridIndex, __global const int* restrict pmeAtomRange,\n"
"        __global real* restrict pmeGrid, __global const real4* restrict pmeBsplineTheta, real4 periodicBoxSize, real4 invPeriodicBoxSize,\n"
"        real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ\n"
"#ifdef USE_LJPME\n"
"        , __global const float2* restrict sigmaEpsilon\n"
"#else\n"
"        , __global const real* restrict charges\n"
"#endif\n"
"    ) {\n"
"    const int firstx = get_global_id(0)*GRID_SIZE_X/get_global_size(0);\n"
"    const int lastx = (get_global_id(0)+1)*GRID_SIZE_X/get_global_size(0);\n"
"    if (firstx == lastx)\n"
"        return;\n"
"    const real4 scale = 1/(real) (PME_ORDER-1);\n"
"    real4 data[PME_ORDER];\n"
"    \n"
"    // Process the atoms in spatially sorted order.  This improves efficiency when writing\n"
"    // the grid values.\n"
"    \n"
"    for (int i = 0; i < NUM_ATOMS; i++) {\n"
"        int atom = i;//pmeAtomGridIndex[i].x;\n"
"        real4 pos = posq[atom];\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"        real3 t = (real3) (pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x,\n"
"                           pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y,\n"
"                           pos.z*recipBoxVecZ.z);\n"
"        t.x = (t.x-floor(t.x))*GRID_SIZE_X;\n"
"        t.y = (t.y-floor(t.y))*GRID_SIZE_Y;\n"
"        t.z = (t.z-floor(t.z))*GRID_SIZE_Z;\n"
"        int4 gridIndex = (int4) (((int) t.x) % GRID_SIZE_X,\n"
"                                 ((int) t.y) % GRID_SIZE_Y,\n"
"                                 ((int) t.z) % GRID_SIZE_Z, 0);\n"
"\n"
"        // Spread the charge from this atom onto each grid point.\n"
"\n"
"#ifdef USE_LJPME\n"
"        const float2 sigEps = sigmaEpsilon[atom];\n"
"        const real charge = 8*sigEps.x*sigEps.x*sigEps.x*sigEps.y;\n"
"#else\n"
"        const real charge = (CHARGE)*EPSILON_FACTOR;\n"
"#endif\n"
"        if (charge == 0)\n"
"            continue;\n"
"        bool hasComputedThetas = false;\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xindex = gridIndex.x+ix;\n"
"            xindex -= (xindex >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            if (xindex < firstx || xindex >= lastx)\n"
"                continue;\n"
"            if (!hasComputedThetas) {\n"
"                hasComputedThetas = true;\n"
"                \n"
"                // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"                // from global memory.\n"
"\n"
"                real4 dr = (real4) (t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z, 0.0f);\n"
"                data[PME_ORDER-1] = 0.0f;\n"
"                data[1] = dr;\n"
"                data[0] = 1.0f-dr;\n"
"                for (int j = 3; j < PME_ORDER; j++) {\n"
"                    real div = RECIP(j-1.0f);\n"
"                    data[j-1] = div*dr*data[j-2];\n"
"                    for (int k = 1; k < (j-1); k++)\n"
"                        data[j-k-1] = div*((dr+(real4) k) *data[j-k-2] + (-dr+(real4) (j-k))*data[j-k-1]);\n"
"                    data[0] = div*(- dr+1.0f)*data[0];\n"
"                }\n"
"                data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"                for (int j = 1; j < (PME_ORDER-1); j++)\n"
"                    data[PME_ORDER-j-1] = scale*((dr+(real4) j)*data[PME_ORDER-j-2] + (-dr+(real4) (PME_ORDER-j))*data[PME_ORDER-j-1]);\n"
"                data[0] = scale*(-dr+1.0f)*data[0];\n"
"            }\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int yindex = gridIndex.y+iy;\n"
"                yindex -= (yindex >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = gridIndex.z+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = xindex*GRID_SIZE_Y*GRID_SIZE_Z + yindex*GRID_SIZE_Z + zindex;\n"
"                    pmeGrid[index] += charge*data[ix].x*data[iy].y*data[iz].z;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"#else\n"
"__kernel void gridSpreadCharge(__global const real4* restrict posq, __global const int2* restrict pmeAtomGridIndex, __global const int* restrict pmeAtomRange,\n"
"        __global real* restrict pmeGrid, __global const real4* restrict pmeBsplineTheta\n"
"#ifdef USE_LJPME\n"
"        , __global const float2* restrict sigmaEpsilon\n"
"#else\n"
"        , __global const real* restrict charges\n"
"#endif\n"
"    ) {\n"
"    unsigned int numGridPoints = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"    for (int gridIndex = get_global_id(0); gridIndex < numGridPoints; gridIndex += get_global_size(0)) {\n"
"        // Compute the charge on a grid point.\n"
"\n"
"        int4 gridPoint;\n"
"        gridPoint.x = gridIndex/(GRID_SIZE_Y*GRID_SIZE_Z);\n"
"        int remainder = gridIndex-gridPoint.x*GRID_SIZE_Y*GRID_SIZE_Z;\n"
"        gridPoint.y = remainder/GRID_SIZE_Z;\n"
"        gridPoint.z = remainder-gridPoint.y*GRID_SIZE_Z;\n"
"        real result = 0.0f;\n"
"\n"
"        // Loop over all atoms that affect this grid point.\n"
"\n"
"        for (int ix = 0; ix < PME_ORDER; ++ix) {\n"
"            int x = gridPoint.x-ix+(gridPoint.x >= ix ? 0 : GRID_SIZE_X);\n"
"            for (int iy = 0; iy < PME_ORDER; ++iy) {\n"
"                int y = gridPoint.y-iy+(gridPoint.y >= iy ? 0 : GRID_SIZE_Y);\n"
"                int z1 = gridPoint.z-PME_ORDER+1;\n"
"                z1 += (z1 >= 0 ? 0 : GRID_SIZE_Z);\n"
"                int z2 = (z1 < gridPoint.z ? gridPoint.z : GRID_SIZE_Z-1);\n"
"                int gridIndex1 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z+z1;\n"
"                int gridIndex2 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z+z2;\n"
"                int firstAtom = pmeAtomRange[gridIndex1];\n"
"                int lastAtom = pmeAtomRange[gridIndex2+1];\n"
"                for (int i = firstAtom; i < lastAtom; ++i)\n"
"                {\n"
"                    int2 atomData = pmeAtomGridIndex[i];\n"
"                    int atomIndex = atomData.x;\n"
"                    int z = atomData.y;\n"
"                    int iz = gridPoint.z-z+(gridPoint.z >= z ? 0 : GRID_SIZE_Z);\n"
"                    real atomCharge = pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].w;\n"
"                    result += atomCharge*pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].x*pmeBsplineTheta[atomIndex+iy*NUM_ATOMS].y*pmeBsplineTheta[atomIndex+iz*NUM_ATOMS].z;\n"
"                }\n"
"                if (z1 > gridPoint.z)\n"
"                {\n"
"                    gridIndex1 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z;\n"
"                    gridIndex2 = x*GRID_SIZE_Y*GRID_SIZE_Z+y*GRID_SIZE_Z+gridPoint.z;\n"
"                    firstAtom = pmeAtomRange[gridIndex1];\n"
"                    lastAtom = pmeAtomRange[gridIndex2+1];\n"
"                    for (int i = firstAtom; i < lastAtom; ++i)\n"
"                    {\n"
"                        int2 atomData = pmeAtomGridIndex[i];\n"
"                        int atomIndex = atomData.x;\n"
"                        int z = atomData.y;\n"
"                        int iz = gridPoint.z-z+(gridPoint.z >= z ? 0 : GRID_SIZE_Z);\n"
"                        real atomCharge = pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].w;\n"
"                        result += atomCharge*pmeBsplineTheta[atomIndex+ix*NUM_ATOMS].x*pmeBsplineTheta[atomIndex+iy*NUM_ATOMS].y*pmeBsplineTheta[atomIndex+iz*NUM_ATOMS].z;\n"
"                    }\n"
"                }\n"
"            }\n"
"        }\n"
"        pmeGrid[gridIndex] = result*EPSILON_FACTOR;\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"__kernel void reciprocalConvolution(__global real2* restrict pmeGrid, __global const real* restrict pmeBsplineModuliX,\n"
"        __global const real* restrict pmeBsplineModuliY, __global const real* restrict pmeBsplineModuliZ, real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"    // R2C stores into a half complex matrix where the last dimension is cut by half\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*(GRID_SIZE_Z/2+1);\n"
"#ifdef USE_LJPME\n"
"    const real recipScaleFactor = -(2*M_PI/6)*SQRT(M_PI)*recipBoxVecX.x*recipBoxVecY.y*recipBoxVecZ.z;\n"
"    real bfac = M_PI / EWALD_ALPHA;\n"
"    real fac1 = 2*M_PI*M_PI*M_PI*SQRT(M_PI);\n"
"    real fac2 = EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA;\n"
"    real fac3 = -2*EWALD_ALPHA*M_PI*M_PI;\n"
"#else\n"
"    const real recipScaleFactor = (1.0f/M_PI)*recipBoxVecX.x*recipBoxVecY.y*recipBoxVecZ.z;\n"
"#endif\n"
"\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        // real indices\n"
"        int kx = index/(GRID_SIZE_Y*(GRID_SIZE_Z/2+1));\n"
"        int remainder = index-kx*GRID_SIZE_Y*(GRID_SIZE_Z/2+1);\n"
"        int ky = remainder/(GRID_SIZE_Z/2+1);\n"
"        int kz = remainder-ky*(GRID_SIZE_Z/2+1);\n"
"        int mx = (kx < (GRID_SIZE_X+1)/2) ? kx : (kx-GRID_SIZE_X);\n"
"        int my = (ky < (GRID_SIZE_Y+1)/2) ? ky : (ky-GRID_SIZE_Y);\n"
"        int mz = (kz < (GRID_SIZE_Z+1)/2) ? kz : (kz-GRID_SIZE_Z);\n"
"        real mhx = mx*recipBoxVecX.x;\n"
"        real mhy = mx*recipBoxVecY.x+my*recipBoxVecY.y;\n"
"        real mhz = mx*recipBoxVecZ.x+my*recipBoxVecZ.y+mz*recipBoxVecZ.z;\n"
"        real bx = pmeBsplineModuliX[kx];\n"
"        real by = pmeBsplineModuliY[ky];\n"
"        real bz = pmeBsplineModuliZ[kz];\n"
"        real2 grid = pmeGrid[index];\n"
"        real m2 = mhx*mhx+mhy*mhy+mhz*mhz;\n"
"#ifdef USE_LJPME\n"
"        real denom = recipScaleFactor/(bx*by*bz);\n"
"        real m = SQRT(m2);\n"
"        real m3 = m*m2;\n"
"        real b = bfac*m;\n"
"        real expfac = -b*b;\n"
"        real expterm = EXP(expfac);\n"
"        real erfcterm = erfc(b);\n"
"        real eterm = (fac1*erfcterm*m3 + expterm*(fac2 + fac3*m2)) * denom;\n"
"        pmeGrid[index] = (real2) (grid.x*eterm, grid.y*eterm);\n"
"#else\n"
"        real denom = m2*bx*by*bz;\n"
"        real eterm = recipScaleFactor*EXP(-RECIP_EXP_FACTOR*m2)/denom;\n"
"        if (kx != 0 || ky != 0 || kz != 0) {\n"
"            pmeGrid[index] = (real2) (grid.x*eterm, grid.y*eterm);\n"
"        }\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"__kernel void gridEvaluateEnergy(__global real2* restrict pmeGrid, __global mixed* restrict energyBuffer,\n"
"                      __global const real* restrict pmeBsplineModuliX, __global const real* restrict pmeBsplineModuliY, __global const real* restrict pmeBsplineModuliZ,\n"
"                      real4 recipBoxVecX, real4 recipBoxVecY, real4 recipBoxVecZ) {\n"
"    // R2C stores into a half complex matrix where the last dimension is cut by half\n"
"    const unsigned int gridSize = GRID_SIZE_X*GRID_SIZE_Y*GRID_SIZE_Z;\n"
" #ifdef USE_LJPME\n"
"    const real recipScaleFactor = -(2*M_PI/6)*SQRT(M_PI)*recipBoxVecX.x*recipBoxVecY.y*recipBoxVecZ.z;\n"
"    real bfac = M_PI / EWALD_ALPHA;\n"
"    real fac1 = 2*M_PI*M_PI*M_PI*SQRT(M_PI);\n"
"    real fac2 = EWALD_ALPHA*EWALD_ALPHA*EWALD_ALPHA;\n"
"    real fac3 = -2*EWALD_ALPHA*M_PI*M_PI;\n"
"#else\n"
"    const real recipScaleFactor = (1.0f/M_PI)*recipBoxVecX.x*recipBoxVecY.y*recipBoxVecZ.z;\n"
"#endif\n"
" \n"
"    mixed energy = 0;\n"
"    for (int index = get_global_id(0); index < gridSize; index += get_global_size(0)) {\n"
"        // real indices\n"
"        int kx = index/(GRID_SIZE_Y*(GRID_SIZE_Z));\n"
"        int remainder = index-kx*GRID_SIZE_Y*(GRID_SIZE_Z);\n"
"        int ky = remainder/(GRID_SIZE_Z);\n"
"        int kz = remainder-ky*(GRID_SIZE_Z);\n"
"        int mx = (kx < (GRID_SIZE_X+1)/2) ? kx : (kx-GRID_SIZE_X);\n"
"        int my = (ky < (GRID_SIZE_Y+1)/2) ? ky : (ky-GRID_SIZE_Y);\n"
"        int mz = (kz < (GRID_SIZE_Z+1)/2) ? kz : (kz-GRID_SIZE_Z);\n"
"        real mhx = mx*recipBoxVecX.x;\n"
"        real mhy = mx*recipBoxVecY.x+my*recipBoxVecY.y;\n"
"        real mhz = mx*recipBoxVecZ.x+my*recipBoxVecZ.y+mz*recipBoxVecZ.z;\n"
"        real m2 = mhx*mhx+mhy*mhy+mhz*mhz;\n"
"        real bx = pmeBsplineModuliX[kx];\n"
"        real by = pmeBsplineModuliY[ky];\n"
"        real bz = pmeBsplineModuliZ[kz];\n"
"#ifdef USE_LJPME\n"
"        real denom = recipScaleFactor/(bx*by*bz);\n"
"        real m = SQRT(m2);\n"
"        real m3 = m*m2;\n"
"        real b = bfac*m;\n"
"        real expfac = -b*b;\n"
"        real expterm = EXP(expfac);\n"
"        real erfcterm = erfc(b);\n"
"        real eterm = (fac1*erfcterm*m3 + expterm*(fac2 + fac3*m2)) * denom;\n"
"#else\n"
"        real denom = m2*bx*by*bz;\n"
"        real eterm = recipScaleFactor*EXP(-RECIP_EXP_FACTOR*m2)/denom;\n"
"#endif\n"
"        if (kz >= (GRID_SIZE_Z/2+1)) {\n"
"            kx = ((kx == 0) ? kx : GRID_SIZE_X-kx);\n"
"            ky = ((ky == 0) ? ky : GRID_SIZE_Y-ky);\n"
"            kz = GRID_SIZE_Z-kz;\n"
"        } \n"
"        int indexInHalfComplexGrid = kz + ky*(GRID_SIZE_Z/2+1)+kx*(GRID_SIZE_Y*(GRID_SIZE_Z/2+1));\n"
"        real2 grid = pmeGrid[indexInHalfComplexGrid];\n"
"#ifndef USE_LJPME\n"
"        if (kx != 0 || ky != 0 || kz != 0)\n"
"#endif\n"
"            energy += eterm*(grid.x*grid.x + grid.y*grid.y);\n"
"    }\n"
"#if defined(USE_PME_STREAM) && !defined(USE_LJPME)\n"
"    energyBuffer[get_global_id(0)] = 0.5f*energy;\n"
"#else\n"
"    energyBuffer[get_global_id(0)] += 0.5f*energy;\n"
"#endif\n"
"}\n"
"\n"
"__kernel void gridInterpolateForce(__global const real4* restrict posq, __global real4* restrict forceBuffers, __global const real* restrict pmeGrid,\n"
"        real4 periodicBoxSize, real4 invPeriodicBoxSize, real4 periodicBoxVecX, real4 periodicBoxVecY, real4 periodicBoxVecZ, real4 recipBoxVecX,\n"
"        real4 recipBoxVecY, real4 recipBoxVecZ, __global int2* restrict pmeAtomGridIndex\n"
"#ifdef USE_LJPME\n"
"        , __global const float2* restrict sigmaEpsilon\n"
"#else\n"
"        , __global const real* restrict charges\n"
"#endif\n"
"    ) {\n"
"    const real scale = 1/(real) (PME_ORDER-1);\n"
"    real4 data[PME_ORDER];\n"
"    real4 ddata[PME_ORDER];\n"
"    \n"
"    // Process the atoms in spatially sorted order.  This improves cache performance when loading\n"
"    // the grid values.\n"
"    \n"
"    for (int i = get_global_id(0); i < NUM_ATOMS; i += get_global_size(0)) {\n"
"        int atom = pmeAtomGridIndex[i].x;\n"
"        real4 force = 0.0f;\n"
"        real4 pos = posq[atom];\n"
"        APPLY_PERIODIC_TO_POS(pos)\n"
"        real3 t = (real3) (pos.x*recipBoxVecX.x+pos.y*recipBoxVecY.x+pos.z*recipBoxVecZ.x,\n"
"                           pos.y*recipBoxVecY.y+pos.z*recipBoxVecZ.y,\n"
"                           pos.z*recipBoxVecZ.z);\n"
"        t.x = (t.x-floor(t.x))*GRID_SIZE_X;\n"
"        t.y = (t.y-floor(t.y))*GRID_SIZE_Y;\n"
"        t.z = (t.z-floor(t.z))*GRID_SIZE_Z;\n"
"        int4 gridIndex = (int4) (((int) t.x) % GRID_SIZE_X,\n"
"                                 ((int) t.y) % GRID_SIZE_Y,\n"
"                                 ((int) t.z) % GRID_SIZE_Z, 0);\n"
"\n"
"        // Since we need the full set of thetas, it's faster to compute them here than load them\n"
"        // from global memory.\n"
"\n"
"        real4 dr = (real4) (t.x-(int) t.x, t.y-(int) t.y, t.z-(int) t.z, 0.0f);\n"
"        data[PME_ORDER-1] = 0.0f;\n"
"        data[1] = dr;\n"
"        data[0] = 1.0f-dr;\n"
"        for (int j = 3; j < PME_ORDER; j++) {\n"
"            real div = RECIP(j-1.0f);\n"
"            data[j-1] = div*dr*data[j-2];\n"
"            for (int k = 1; k < (j-1); k++)\n"
"                data[j-k-1] = div*((dr+(real4) k) *data[j-k-2] + (-dr+(real4) (j-k))*data[j-k-1]);\n"
"            data[0] = div*(-dr+1.0f)*data[0];\n"
"        }\n"
"        ddata[0] = -data[0];\n"
"        for (int j = 1; j < PME_ORDER; j++)\n"
"            ddata[j] = data[j-1]-data[j];\n"
"        data[PME_ORDER-1] = scale*dr*data[PME_ORDER-2];\n"
"        for (int j = 1; j < (PME_ORDER-1); j++)\n"
"            data[PME_ORDER-j-1] = scale*((dr+(real4) j)*data[PME_ORDER-j-2] + (-dr+(real4) (PME_ORDER-j))*data[PME_ORDER-j-1]);\n"
"        data[0] = scale*(-dr+1.0f)*data[0];\n"
"\n"
"        // Compute the force on this atom.\n"
"\n"
"        for (int ix = 0; ix < PME_ORDER; ix++) {\n"
"            int xindex = gridIndex.x+ix;\n"
"            xindex -= (xindex >= GRID_SIZE_X ? GRID_SIZE_X : 0);\n"
"            for (int iy = 0; iy < PME_ORDER; iy++) {\n"
"                int yindex = gridIndex.y+iy;\n"
"                yindex -= (yindex >= GRID_SIZE_Y ? GRID_SIZE_Y : 0);\n"
"                for (int iz = 0; iz < PME_ORDER; iz++) {\n"
"                    int zindex = gridIndex.z+iz;\n"
"                    zindex -= (zindex >= GRID_SIZE_Z ? GRID_SIZE_Z : 0);\n"
"                    int index = xindex*GRID_SIZE_Y*GRID_SIZE_Z + yindex*GRID_SIZE_Z + zindex;\n"
"                    real gridvalue = pmeGrid[index];\n"
"                    force.x += ddata[ix].x*data[iy].y*data[iz].z*gridvalue;\n"
"                    force.y += data[ix].x*ddata[iy].y*data[iz].z*gridvalue;\n"
"                    force.z += data[ix].x*data[iy].y*ddata[iz].z*gridvalue;\n"
"                }\n"
"            }\n"
"        }\n"
"        real4 totalForce = forceBuffers[atom];\n"
"#ifdef USE_LJPME\n"
"        const float2 sigEps = sigmaEpsilon[atom];\n"
"        real q = 8*sigEps.x*sigEps.x*sigEps.x*sigEps.y;\n"
"#else\n"
"        real q = CHARGE*EPSILON_FACTOR;\n"
"#endif\n"
"        totalForce.x -= q*(force.x*GRID_SIZE_X*recipBoxVecX.x);\n"
"        totalForce.y -= q*(force.x*GRID_SIZE_X*recipBoxVecY.x+force.y*GRID_SIZE_Y*recipBoxVecY.y);\n"
"        totalForce.z -= q*(force.x*GRID_SIZE_X*recipBoxVecZ.x+force.y*GRID_SIZE_Y*recipBoxVecZ.y+force.z*GRID_SIZE_Z*recipBoxVecZ.z);\n"
"        forceBuffers[atom] = totalForce;\n"
"    }\n"
"}\n"
"\n"
"__kernel void addForces(__global const real4* restrict forces, __global real4* restrict forceBuffers) {\n"
"    for (int atom = get_global_id(0); atom < NUM_ATOMS; atom += get_global_size(0))\n"
"        forceBuffers[atom] += forces[atom];\n"
"}\n"
"\n"
"__kernel void addEnergy(__global const mixed* restrict pmeEnergyBuffer, __global mixed* restrict energyBuffer, int bufferSize) {\n"
"    for (int i = get_global_id(0); i < bufferSize; i += get_global_size(0))\n"
"        energyBuffer[i] += pmeEnergyBuffer[i];\n"
"}\n"
"";
const string OpenCLKernelSources::pmeExclusions = "const float4 exclusionParams = PARAMS[index];\n"
"real3 delta = (real3) (pos2.x-pos1.x, pos2.y-pos1.y, pos2.z-pos1.z);\n"
"#if USE_PERIODIC\n"
"    APPLY_PERIODIC_TO_DELTA(delta)\n"
"#endif\n"
"const real r2 = delta.x*delta.x + delta.y*delta.y + delta.z*delta.z;\n"
"const real r = SQRT(r2);\n"
"const real invR = RECIP(r);\n"
"const real alphaR = EWALD_ALPHA*r;\n"
"const real expAlphaRSqr = EXP(-alphaR*alphaR);\n"
"real tempForce = 0.0f;\n"
"if (alphaR > 1e-6f) {\n"
"    const real erfAlphaR = erf(alphaR);\n"
"    const real prefactor = exclusionParams.x*invR;\n"
"    tempForce = -prefactor*(erfAlphaR-alphaR*expAlphaRSqr*TWO_OVER_SQRT_PI);\n"
"    energy -= prefactor*erfAlphaR;\n"
"}\n"
"else {\n"
"    energy -= TWO_OVER_SQRT_PI*EWALD_ALPHA*exclusionParams.x;\n"
"}\n"
"#if DO_LJPME\n"
"const real dispersionAlphaR = EWALD_DISPERSION_ALPHA*r;\n"
"const real dar2 = dispersionAlphaR*dispersionAlphaR;\n"
"const real dar4 = dar2*dar2;\n"
"const real dar6 = dar4*dar2;\n"
"const real invR2 = invR*invR;\n"
"const real expDar2 = EXP(-dar2);\n"
"const real c6 = 64*exclusionParams.y*exclusionParams.y*exclusionParams.y*exclusionParams.z;\n"
"const real coef = invR2*invR2*invR2*c6;\n"
"const real eprefac = 1.0f + dar2 + 0.5f*dar4;\n"
"const real dprefac = eprefac + dar6/6.0f;\n"
"energy += coef*(1.0f - expDar2*eprefac);\n"
"tempForce += 6.0f*coef*(1.0f - expDar2*dprefac);\n"
"#endif\n"
"if (r > 0)\n"
"    delta *= tempForce*invR*invR;\n"
"real3 force1 = -delta;\n"
"real3 force2 = delta;\n"
"";
const string OpenCLKernelSources::sort = "#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"\n"
"KEY_TYPE getValue(DATA_TYPE value) {\n"
"    return SORT_KEY;\n"
"}\n"
"\n"
"/**\n"
" * Sort a list that is short enough to entirely fit in local memory.  This is executed as\n"
" * a single thread block.\n"
" */\n"
"__kernel void sortShortList(__global DATA_TYPE* restrict data, uint length, __local DATA_TYPE* dataBuffer) {\n"
"    // Load the data into local memory.\n"
"    \n"
"    for (int index = get_local_id(0); index < length; index += get_local_size(0))\n"
"        dataBuffer[index] = data[index];\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Perform a bitonic sort in local memory.\n"
"\n"
"    for (unsigned int k = 2; k < 2*length; k *= 2) {\n"
"        for (unsigned int j = k/2; j > 0; j /= 2) {\n"
"            for (unsigned int i = get_local_id(0); i < length; i += get_local_size(0)) {\n"
"                int ixj = i^j;\n"
"                if (ixj > i && ixj < length) {\n"
"                    DATA_TYPE value1 = dataBuffer[i];\n"
"                    DATA_TYPE value2 = dataBuffer[ixj];\n"
"                    bool ascending = ((i&k) == 0);\n"
"                    for (unsigned int mask = k*2; mask < 2*length; mask *= 2)\n"
"                        ascending = ((i&mask) == 0 ? !ascending : ascending);\n"
"                    KEY_TYPE lowKey  = (ascending ? getValue(value1) : getValue(value2));\n"
"                    KEY_TYPE highKey = (ascending ? getValue(value2) : getValue(value1));\n"
"                    if (lowKey > highKey) {\n"
"                        dataBuffer[i] = value2;\n"
"                        dataBuffer[ixj] = value1;\n"
"                    }\n"
"                }\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"    }\n"
"\n"
"    // Write the data back to global memory.\n"
"\n"
"    for (int index = get_local_id(0); index < length; index += get_local_size(0))\n"
"        data[index] = dataBuffer[index];\n"
"}\n"
"\n"
"/**\n"
" * An alternate kernel for sorting short lists.  In this version every thread does a full\n"
" * scan through the data to select the destination for one element.  This involves more\n"
" * work, but also parallelizes much better.\n"
" */\n"
"__kernel void sortShortList2(__global const DATA_TYPE* restrict dataIn, __global DATA_TYPE* restrict dataOut, int length) {\n"
"    __local DATA_TYPE dataBuffer[64];\n"
"    DATA_TYPE value = dataIn[get_global_id(0) < length ? get_global_id(0) : 0];\n"
"    KEY_TYPE key = getValue(value);\n"
"    int count = 0;\n"
"    for (int blockStart = 0; blockStart < length; blockStart += get_local_size(0)) {\n"
"        int numInBlock = min((int) get_local_size(0), length-blockStart);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (get_local_id(0) < numInBlock)\n"
"            dataBuffer[get_local_id(0)] = dataIn[blockStart+get_local_id(0)];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        for (int i = 0; i < numInBlock; i++) {\n"
"            KEY_TYPE otherKey = getValue(dataBuffer[i]);\n"
"            if (otherKey < key || (otherKey == key && blockStart+i < get_global_id(0)))\n"
"                count++;\n"
"        }\n"
"    }\n"
"    if (get_global_id(0) < length)\n"
"        dataOut[count] = value;\n"
"}\n"
"\n"
"/**\n"
" * Calculate the minimum and maximum value in the array to be sorted.  This kernel\n"
" * is executed as a single work group.\n"
" */\n"
"__kernel void computeRange(__global const DATA_TYPE* restrict data, uint length, __global KEY_TYPE* restrict range, __local KEY_TYPE* restrict minBuffer,\n"
"        __local KEY_TYPE* restrict maxBuffer, uint numBuckets, __global uint* restrict bucketOffset) {\n"
"    KEY_TYPE minimum = MAX_KEY;\n"
"    KEY_TYPE maximum = MIN_KEY;\n"
"\n"
"    // Each thread calculates the range of a subset of values.\n"
"\n"
"    for (uint index = get_local_id(0); index < length; index += get_local_size(0)) {\n"
"        KEY_TYPE value = getValue(data[index]);\n"
"        minimum = min(minimum, value);\n"
"        maximum = max(maximum, value);\n"
"    }\n"
"\n"
"    // Now reduce them.\n"
"\n"
"    minBuffer[get_local_id(0)] = minimum;\n"
"    maxBuffer[get_local_id(0)] = maximum;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (uint step = 1; step < get_local_size(0); step *= 2) {\n"
"        if (get_local_id(0)+step < get_local_size(0) && get_local_id(0)%(2*step) == 0) {\n"
"            minBuffer[get_local_id(0)] = min(minBuffer[get_local_id(0)], minBuffer[get_local_id(0)+step]);\n"
"            maxBuffer[get_local_id(0)] = max(maxBuffer[get_local_id(0)], maxBuffer[get_local_id(0)+step]);\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    minimum = minBuffer[0];\n"
"    maximum = maxBuffer[0];\n"
"    if (get_local_id(0) == 0) {\n"
"        range[0] = minimum;\n"
"        range[1] = maximum;\n"
"    }\n"
"    \n"
"    // Clear the bucket counters in preparation for the next kernel.\n"
"\n"
"    for (uint index = get_local_id(0); index < numBuckets; index += get_local_size(0))\n"
"        bucketOffset[index] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Assign elements to buckets.\n"
" */\n"
"__kernel void assignElementsToBuckets(__global const DATA_TYPE* restrict data, uint length, uint numBuckets, __global const KEY_TYPE* restrict range,\n"
"        __global uint* restrict bucketOffset, __global uint* restrict bucketOfElement, __global uint* restrict offsetInBucket) {\n"
"#ifdef AMD_ATOMIC_WORK_AROUND\n"
"    // Do a byte write to force all memory accesses to interactionCount to use the complete path.\n"
"    // This avoids the atomic access from causing all word accesses to other buffers from using the slow complete path.\n"
"    // The IF actually causes the write to never be executed, its presence is all that is needed.\n"
"    // AMD APP SDK 2.4 has this problem.\n"
"    if (get_global_id(0) == get_local_id(0)+1)\n"
"        ((__global char*)bucketOffset)[sizeof(int)*numBuckets+1] = 0;\n"
"#endif\n"
"    float minValue = (float) (range[0]);\n"
"    float maxValue = (float) (range[1]);\n"
"    float bucketWidth = (maxValue-minValue)/numBuckets;\n"
"    for (uint index = get_global_id(0); index < length; index += get_global_size(0)) {\n"
"        float key = (float) getValue(data[index]);\n"
"        uint bucketIndex = min((uint) ((key-minValue)/bucketWidth), numBuckets-1);\n"
"        offsetInBucket[index] = atom_inc(&bucketOffset[bucketIndex]);\n"
"        bucketOfElement[index] = bucketIndex;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sum the bucket sizes to compute the start position of each bucket.  This kernel\n"
" * is executed as a single work group.\n"
" */\n"
"__kernel void computeBucketPositions(uint numBuckets, __global uint* restrict bucketOffset, __local uint* restrict buffer) {\n"
"    uint globalOffset = 0;\n"
"    for (uint startBucket = 0; startBucket < numBuckets; startBucket += get_local_size(0)) {\n"
"        // Load the bucket sizes into local memory.\n"
"\n"
"        uint globalIndex = startBucket+get_local_id(0);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        buffer[get_local_id(0)] = (globalIndex < numBuckets ? bucketOffset[globalIndex] : 0);\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Perform a parallel prefix sum.\n"
"\n"
"        for (uint step = 1; step < get_local_size(0); step *= 2) {\n"
"            uint add = (get_local_id(0) >= step ? buffer[get_local_id(0)-step] : 0);\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            buffer[get_local_id(0)] += add;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"        }\n"
"\n"
"        // Write the results back to global memory.\n"
"\n"
"        if (globalIndex < numBuckets)\n"
"            bucketOffset[globalIndex] = buffer[get_local_id(0)]+globalOffset;\n"
"        globalOffset += buffer[get_local_size(0)-1];\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Copy the input data into the buckets for sorting.\n"
" */\n"
"__kernel void copyDataToBuckets(__global const DATA_TYPE* restrict data, __global DATA_TYPE* restrict buckets, uint length, __global const uint* restrict bucketOffset, __global const uint* restrict bucketOfElement, __global const uint* restrict offsetInBucket) {\n"
"    for (uint index = get_global_id(0); index < length; index += get_global_size(0)) {\n"
"        DATA_TYPE element = data[index];\n"
"        uint bucketIndex = bucketOfElement[index];\n"
"        uint offset = (bucketIndex == 0 ? 0 : bucketOffset[bucketIndex-1]);\n"
"        buckets[offset+offsetInBucket[index]] = element;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sort the data in each bucket.\n"
" */\n"
"__kernel void sortBuckets(__global DATA_TYPE* restrict data, __global const DATA_TYPE* restrict buckets, uint numBuckets, __global const uint* restrict bucketOffset, __local DATA_TYPE* restrict buffer) {\n"
"    for (int index = get_group_id(0); index < numBuckets; index += get_num_groups(0)) {\n"
"        int startIndex = (index == 0 ? 0 : bucketOffset[index-1]);\n"
"        int endIndex = bucketOffset[index];\n"
"        int length = endIndex-startIndex;\n"
"        if (length <= get_local_size(0)) {\n"
"            // Load the data into local memory.\n"
"\n"
"            if (get_local_id(0) < length)\n"
"                buffer[get_local_id(0)] = buckets[startIndex+get_local_id(0)];\n"
"            else\n"
"                buffer[get_local_id(0)] = MAX_VALUE;\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"            // Perform a bitonic sort in local memory.\n"
"\n"
"            for (int k = 2; k <= get_local_size(0); k *= 2) {\n"
"                for (int j = k/2; j > 0; j /= 2) {\n"
"                    int ixj = get_local_id(0)^j;\n"
"                    if (ixj > get_local_id(0)) {\n"
"                        DATA_TYPE value1 = buffer[get_local_id(0)];\n"
"                        DATA_TYPE value2 = buffer[ixj];\n"
"                        bool ascending = (get_local_id(0)&k) == 0;\n"
"                        KEY_TYPE lowKey = (ascending ? getValue(value1) : getValue(value2));\n"
"                        KEY_TYPE highKey = (ascending ? getValue(value2) : getValue(value1));\n"
"                        if (lowKey > highKey) {\n"
"                            buffer[get_local_id(0)] = value2;\n"
"                            buffer[ixj] = value1;\n"
"                        }\n"
"                    }\n"
"                    barrier(CLK_LOCAL_MEM_FENCE);\n"
"                }\n"
"            }\n"
"\n"
"            // Write the data to the sorted array.\n"
"\n"
"            if (get_local_id(0) < length)\n"
"                data[startIndex+get_local_id(0)] = buffer[get_local_id(0)];\n"
"        }\n"
"        else {\n"
"            // Copy the bucket data over to the output array.\n"
"\n"
"            for (int i = get_local_id(0); i < length; i += get_local_size(0))\n"
"                data[startIndex+i] = buckets[startIndex+i];\n"
"            barrier(CLK_GLOBAL_MEM_FENCE);\n"
"\n"
"            // Perform a bitonic sort in global memory.\n"
"\n"
"            for (int k = 2; k < 2*length; k *= 2) {\n"
"                for (int j = k/2; j > 0; j /= 2) {\n"
"                    for (int i = get_local_id(0); i < length; i += get_local_size(0)) {\n"
"                        int ixj = i^j;\n"
"                        if (ixj > i && ixj < length) {\n"
"                            DATA_TYPE value1 = data[startIndex+i];\n"
"                            DATA_TYPE value2 = data[startIndex+ixj];\n"
"                            bool ascending = ((i&k) == 0);\n"
"                            for (int mask = k*2; mask < 2*length; mask *= 2)\n"
"                                ascending = ((i&mask) == 0 ? !ascending : ascending);\n"
"                            KEY_TYPE lowKey  = (ascending ? getValue(value1) : getValue(value2));\n"
"                            KEY_TYPE highKey = (ascending ? getValue(value2) : getValue(value1));\n"
"                            if (lowKey > highKey) {\n"
"                                data[startIndex+i] = value2;\n"
"                                data[startIndex+ixj] = value1;\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                    barrier(CLK_GLOBAL_MEM_FENCE);\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"";
const string OpenCLKernelSources::torsionForce = "const real PI = 3.14159265358979323846f;\n"
"real4 v0 = (real4) (pos1.xyz-pos2.xyz, 0.0f);\n"
"real4 v1 = (real4) (pos3.xyz-pos2.xyz, 0.0f);\n"
"real4 v2 = (real4) (pos3.xyz-pos4.xyz, 0.0f);\n"
"#if APPLY_PERIODIC\n"
"APPLY_PERIODIC_TO_DELTA(v0)\n"
"APPLY_PERIODIC_TO_DELTA(v1)\n"
"APPLY_PERIODIC_TO_DELTA(v2)\n"
"#endif\n"
"real4 cp0 = cross(v0, v1);\n"
"real4 cp1 = cross(v1, v2);\n"
"real cosangle = dot(normalize(cp0), normalize(cp1));\n"
"real theta;\n"
"if (cosangle > 0.99f || cosangle < -0.99f) {\n"
"    // We're close to the singularity in acos(), so take the cross product and use asin() instead.\n"
"\n"
"    real4 cross_prod = cross(cp0, cp1);\n"
"    real scale = dot(cp0, cp0)*dot(cp1, cp1);\n"
"    theta = asin(SQRT(dot(cross_prod, cross_prod)/scale));\n"
"    if (cosangle < 0)\n"
"        theta = PI-theta;\n"
"}\n"
"else\n"
"   theta = acos(cosangle);\n"
"theta = (dot(v0, cp1) >= 0 ? theta : -theta);\n"
"COMPUTE_FORCE\n"
"real normCross1 = dot(cp0, cp0);\n"
"real normSqrBC = dot(v1, v1);\n"
"real normBC = SQRT(normSqrBC);\n"
"real normCross2 = dot(cp1, cp1);\n"
"real dp = 1.0f/normSqrBC;\n"
"real4 ff = (real4) ((-dEdAngle*normBC)/normCross1, dot(v0, v1)*dp, dot(v2, v1)*dp, (dEdAngle*normBC)/normCross2);\n"
"real4 force1 = ff.x*cp0;\n"
"real4 force4 = ff.w*cp1;\n"
"real4 s = ff.y*force1 - ff.z*force4;\n"
"real4 force2 = s-force1;\n"
"real4 force3 = -s-force4;\n"
"";
const string OpenCLKernelSources::utilities = "/**\n"
" * Fill a buffer with 0.\n"
" */\n"
"\n"
"__kernel void clearBuffer(__global int* restrict buffer, int size) {\n"
"    int index = get_global_id(0);\n"
"    __global int4* buffer4 = (__global int4*) buffer;\n"
"    int sizeDiv4 = size/4;\n"
"    while (index < sizeDiv4) {\n"
"        buffer4[index] = (int4) 0;\n"
"        index += get_global_size(0);\n"
"    }\n"
"    if (get_global_id(0) == 0)\n"
"        for (int i = sizeDiv4*4; i < size; i++)\n"
"            buffer[i] = 0;\n"
"}\n"
"\n"
"/**\n"
" * Fill two buffers with 0.\n"
" */\n"
"__kernel void clearTwoBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"}\n"
"\n"
"/**\n"
" * Fill three buffers with 0.\n"
" */\n"
"__kernel void clearThreeBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"}\n"
"\n"
"/**\n"
" * Fill four buffers with 0.\n"
" */\n"
"__kernel void clearFourBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3, __global int* restrict buffer4, int size4) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"    clearBuffer(buffer4, size4);\n"
"}\n"
"\n"
"/**\n"
" * Fill five buffers with 0.\n"
" */\n"
"__kernel void clearFiveBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3, __global int* restrict buffer4, int size4, __global int* restrict buffer5, int size5) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"    clearBuffer(buffer4, size4);\n"
"    clearBuffer(buffer5, size5);\n"
"}\n"
"\n"
"/**\n"
" * Fill six buffers with 0.\n"
" */\n"
"__kernel void clearSixBuffers(__global int* restrict buffer1, int size1, __global int* restrict buffer2, int size2, __global int* restrict buffer3, int size3, __global int* restrict buffer4, int size4, __global int* restrict buffer5, int size5, __global int* restrict buffer6, int size6) {\n"
"    clearBuffer(buffer1, size1);\n"
"    clearBuffer(buffer2, size2);\n"
"    clearBuffer(buffer3, size3);\n"
"    clearBuffer(buffer4, size4);\n"
"    clearBuffer(buffer5, size5);\n"
"    clearBuffer(buffer6, size6);\n"
"}\n"
"\n"
"/**\n"
" * Sum a collection of buffers into the first one.\n"
" */\n"
"\n"
"__kernel void reduceReal4Buffer(__global real4* restrict buffer, int bufferSize, int numBuffers) {\n"
"    int index = get_global_id(0);\n"
"    int totalSize = bufferSize*numBuffers;\n"
"    while (index < bufferSize) {\n"
"        real4 sum = buffer[index];\n"
"        for (int i = index+bufferSize; i < totalSize; i += bufferSize)\n"
"            sum += buffer[i];\n"
"        buffer[index] = sum;\n"
"        index += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sum the various buffers containing forces.\n"
" */\n"
"__kernel void reduceForces(__global long* restrict longBuffer, __global real4* restrict buffer, int bufferSize, int numBuffers) {\n"
"    int totalSize = bufferSize*numBuffers;\n"
"    real scale = 1/(real) 0x100000000;\n"
"    for (int index = get_global_id(0); index < bufferSize; index += get_global_size(0)) {\n"
"#ifdef SUPPORTS_64_BIT_ATOMICS\n"
"        real4 sum = (real4) (scale*longBuffer[index], scale*longBuffer[index+bufferSize], scale*longBuffer[index+2*bufferSize], 0);\n"
"#else\n"
"        real4 sum = (real4) 0;\n"
"#endif\n"
"        for (int i = index; i < totalSize; i += bufferSize)\n"
"            sum += buffer[i];\n"
"        buffer[index] = sum;\n"
"        longBuffer[index] = (long) (sum.x*0x100000000);\n"
"        longBuffer[index+bufferSize] = (long) (sum.y*0x100000000);\n"
"        longBuffer[index+2*bufferSize] = (long) (sum.z*0x100000000);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Sum the energy buffer.\n"
" */\n"
"__kernel void reduceEnergy(__global const mixed* restrict energyBuffer, __global mixed* restrict result, int bufferSize, int workGroupSize, __local mixed* tempBuffer) {\n"
"    const unsigned int thread = get_local_id(0);\n"
"    mixed sum = 0;\n"
"    for (unsigned int index = thread; index < bufferSize; index += get_local_size(0))\n"
"        sum += energyBuffer[index];\n"
"    tempBuffer[thread] = sum;\n"
"    for (int i = 1; i < workGroupSize; i *= 2) {\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (thread%(i*2) == 0 && thread+i < workGroupSize)\n"
"            tempBuffer[thread] += tempBuffer[thread+i];\n"
"    }\n"
"    if (thread == 0)\n"
"        *result = tempBuffer[0];\n"
"}\n"
"\n"
"/**\n"
" * This is called to determine the accuracy of various native functions.\n"
" */\n"
"\n"
"__kernel void determineNativeAccuracy(__global float8* restrict values, int numValues) {\n"
"    for (int i = get_global_id(0); i < numValues; i += get_global_size(0)) {\n"
"        float v = values[i].s0;\n"
"        values[i] = (float8) (v, native_sqrt(v), native_rsqrt(v), native_recip(v), native_exp(v), native_log(v), 0.0f, 0.0f);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Record the atomic charges into the posq array.\n"
" */\n"
"__kernel void setCharges(__global real* restrict charges, __global real4* restrict posq, __global int* restrict atomOrder, int numAtoms) {\n"
"    for (int i = get_global_id(0); i < numAtoms; i += get_global_size(0))\n"
"        posq[i].w = charges[atomOrder[i]];\n"
"}";

/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2010 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "OpenCLRpmdKernelSources.h"

using namespace OpenMM;
using namespace std;

const string OpenCLRpmdKernelSources::rpmd = "mixed4 multiplyComplexRealPart(mixed2 c1, mixed4 c2r, mixed4 c2i) {\n"
"    return c1.x*c2r-c1.y*c2i;\n"
"}\n"
"\n"
"mixed4 multiplyComplexImagPart(mixed2 c1, mixed4 c2r, mixed4 c2i) {\n"
"    return c1.x*c2i+c1.y*c2r;\n"
"}\n"
"\n"
"mixed4 multiplyComplexRealPartConj(mixed2 c1, mixed4 c2r, mixed4 c2i) {\n"
"    return c1.x*c2r+c1.y*c2i;\n"
"}\n"
"\n"
"mixed4 multiplyComplexImagPartConj(mixed2 c1, mixed4 c2r, mixed4 c2i) {\n"
"    return c1.x*c2i-c1.y*c2r;\n"
"}\n"
"\n"
"/**\n"
" * Apply the PILE-L thermostat.\n"
" */\n"
"__kernel void applyPileThermostat(__global mixed4* velm, __global float4* random, unsigned int randomIndex,\n"
"        mixed dt, mixed kT, mixed friction) {\n"
"    const int numBlocks = get_global_size(0)/NUM_COPIES;\n"
"    const int blockStart = NUM_COPIES*(get_local_id(0)/NUM_COPIES);\n"
"    const int indexInBlock = get_local_id(0)-blockStart;\n"
"    const mixed nkT = NUM_COPIES*kT;\n"
"    const mixed twown = 2.0f*nkT/HBAR;\n"
"    const mixed c1_0 = exp(-0.5f*dt*friction);\n"
"    const mixed c2_0 = sqrt(1.0f-c1_0*c1_0);\n"
"    __local mixed4 v[2*THREAD_BLOCK_SIZE];\n"
"    __local mixed4 temp[2*THREAD_BLOCK_SIZE];\n"
"    __local mixed2 w[NUM_COPIES];\n"
"    __local mixed4* vreal = &v[blockStart];\n"
"    __local mixed4* vimag = &v[blockStart+get_local_size(0)];\n"
"    if (get_local_id(0) < NUM_COPIES)\n"
"        w[indexInBlock] = (mixed2) (cos(-indexInBlock*2*M_PI/NUM_COPIES), sin(-indexInBlock*2*M_PI/NUM_COPIES));\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    randomIndex += NUM_COPIES*(get_global_id(0)/NUM_COPIES);\n"
"    for (int particle = get_global_id(0)/NUM_COPIES; particle < NUM_ATOMS; particle += numBlocks) {\n"
"        mixed4 particleVelm = velm[particle+indexInBlock*PADDED_NUM_ATOMS];\n"
"        mixed invMass = particleVelm.w;\n"
"        mixed c3_0 = c2_0*sqrt(nkT*invMass);\n"
"        \n"
"        // Forward FFT.\n"
"        \n"
"        vreal[indexInBlock] = SCALE*particleVelm;\n"
"        vimag[indexInBlock] = (mixed4) (0.0f, 0.0f, 0.0f, 0.0f);\n"
"        barrier(CLK_GLOBAL_MEM_FENCE);\n"
"        FFT_V_FORWARD\n"
"\n"
"        // Apply the thermostat.\n"
"\n"
"        if (indexInBlock == 0) {\n"
"            // Apply a local Langevin thermostat to the centroid mode.\n"
"\n"
"            vreal[0].xyz = vreal[0].xyz*c1_0 + c3_0*convert_mixed4(random[randomIndex]).xyz;\n"
"        }\n"
"        else {\n"
"            // Use critical damping white noise for the remaining modes.\n"
"\n"
"            int k = (indexInBlock <= NUM_COPIES/2 ? indexInBlock : NUM_COPIES-indexInBlock);\n"
"            const bool isCenter = (NUM_COPIES%2 == 0 && k == NUM_COPIES/2);\n"
"            const mixed wk = twown*sin(k*M_PI/NUM_COPIES);\n"
"            const mixed c1 = exp(-wk*dt);\n"
"            const mixed c2 = sqrt((1.0f-c1*c1)/2.0f) * (isCenter ? sqrt(2.0f) : 1.0f);\n"
"            const mixed c3 = c2*sqrt(nkT*invMass);\n"
"            mixed4 rand1 = c3*convert_mixed4(random[randomIndex+k]);\n"
"            mixed4 rand2 = (isCenter ? 0.0f : c3*convert_mixed4(random[randomIndex+NUM_COPIES-k]));\n"
"            vreal[indexInBlock].xyz = c1*vreal[indexInBlock].xyz + rand1.xyz;\n"
"            vimag[indexInBlock].xyz = c1*vimag[indexInBlock].xyz + (indexInBlock < NUM_COPIES/2 ? rand2.xyz : -rand2.xyz);\n"
"        }\n"
"        barrier(CLK_GLOBAL_MEM_FENCE);\n"
"        \n"
"        // Inverse FFT.\n"
"        \n"
"        FFT_V_BACKWARD\n"
"        if (invMass != 0)\n"
"            velm[particle+indexInBlock*PADDED_NUM_ATOMS].xyz = SCALE*vreal[indexInBlock].xyz;\n"
"        randomIndex += get_global_size(0);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Advance the positions and velocities.\n"
" */\n"
"__kernel void integrateStep(__global mixed4* posq, __global mixed4* velm, __global real4* force, mixed dt, mixed kT) {\n"
"    const int numBlocks = get_global_size(0)/NUM_COPIES;\n"
"    const int blockStart = NUM_COPIES*(get_local_id(0)/NUM_COPIES);\n"
"    const int indexInBlock = get_local_id(0)-blockStart;\n"
"    const mixed nkT = NUM_COPIES*kT;\n"
"    const mixed twown = 2.0f*nkT/HBAR;\n"
"    __local mixed4 q[2*THREAD_BLOCK_SIZE];\n"
"    __local mixed4 v[2*THREAD_BLOCK_SIZE];\n"
"    __local mixed4 temp[2*THREAD_BLOCK_SIZE];\n"
"    __local mixed2 w[NUM_COPIES];\n"
"\n"
"    // Update velocities.\n"
"    \n"
"    for (int particle = get_global_id(0)/NUM_COPIES; particle < NUM_ATOMS; particle += numBlocks) {\n"
"        int index = particle+indexInBlock*PADDED_NUM_ATOMS;\n"
"        mixed4 particleVelm = velm[index];\n"
"        particleVelm.xyz += convert_mixed4(force[index]).xyz*(0.5f*dt*particleVelm.w);\n"
"        if (particleVelm.w != 0)\n"
"            velm[index] = particleVelm;\n"
"    }\n"
"    \n"
"    // Evolve the free ring polymer by transforming to the frequency domain.\n"
"\n"
"    __local mixed4* qreal = &q[blockStart];\n"
"    __local mixed4* qimag = &q[blockStart+get_local_size(0)];\n"
"    __local mixed4* vreal = &v[blockStart];\n"
"    __local mixed4* vimag = &v[blockStart+get_local_size(0)];\n"
"    if (get_local_id(0) < NUM_COPIES)\n"
"        w[indexInBlock] = (mixed2) (cos(-indexInBlock*2*M_PI/NUM_COPIES), sin(-indexInBlock*2*M_PI/NUM_COPIES));\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (int particle = get_global_id(0)/NUM_COPIES; particle < NUM_ATOMS; particle += numBlocks) {\n"
"        mixed4 particlePosq = posq[particle+indexInBlock*PADDED_NUM_ATOMS];\n"
"        mixed4 particleVelm = velm[particle+indexInBlock*PADDED_NUM_ATOMS];\n"
"        \n"
"        // Forward FFT.\n"
"        \n"
"        qreal[indexInBlock] = SCALE*particlePosq;\n"
"        qimag[indexInBlock] = (mixed4) (0.0f, 0.0f, 0.0f, 0.0f);\n"
"        vreal[indexInBlock] = SCALE*particleVelm;\n"
"        vimag[indexInBlock] = (mixed4) (0.0f, 0.0f, 0.0f, 0.0f);\n"
"        barrier(CLK_GLOBAL_MEM_FENCE);\n"
"        FFT_Q_FORWARD\n"
"        FFT_V_FORWARD\n"
"\n"
"        // Apply the thermostat.\n"
"\n"
"        if (indexInBlock == 0) {\n"
"            qreal[0].xyz += vreal[0].xyz*dt;\n"
"            qimag[0].xyz += vimag[0].xyz*dt;\n"
"        }\n"
"        else {\n"
"            const mixed wk = twown*sin(indexInBlock*M_PI/NUM_COPIES);\n"
"            const mixed wt = wk*dt;\n"
"            const mixed coswt = cos(wt);\n"
"            const mixed sinwt = sin(wt);\n"
"            const mixed4 vprimereal = vreal[indexInBlock]*coswt - qreal[indexInBlock]*(wk*sinwt); // Advance velocity from t to t+dt\n"
"            const mixed4 vprimeimag = vimag[indexInBlock]*coswt - qimag[indexInBlock]*(wk*sinwt);\n"
"            qreal[indexInBlock] = vreal[indexInBlock]*(sinwt/wk) + qreal[indexInBlock]*coswt; // Advance position from t to t+dt\n"
"            qimag[indexInBlock] = vimag[indexInBlock]*(sinwt/wk) + qimag[indexInBlock]*coswt;\n"
"            vreal[indexInBlock] = vprimereal;\n"
"            vimag[indexInBlock] = vprimeimag;\n"
"        }\n"
"        barrier(CLK_GLOBAL_MEM_FENCE);\n"
"        \n"
"        // Inverse FFT.\n"
"        \n"
"        FFT_Q_BACKWARD\n"
"        FFT_V_BACKWARD\n"
"        if (particleVelm.w != 0) {\n"
"            posq[particle+indexInBlock*PADDED_NUM_ATOMS].xyz = SCALE*qreal[indexInBlock].xyz;\n"
"            velm[particle+indexInBlock*PADDED_NUM_ATOMS].xyz = SCALE*vreal[indexInBlock].xyz;\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Advance the velocities by a half step.\n"
" */\n"
"__kernel void advanceVelocities(__global mixed4* velm, __global real4* force, mixed dt) {\n"
"    const int numBlocks = get_global_size(0)/NUM_COPIES;\n"
"    const int blockStart = NUM_COPIES*(get_local_id(0)/NUM_COPIES);\n"
"    const int indexInBlock = get_local_id(0)-blockStart;\n"
"\n"
"    // Update velocities.\n"
"    \n"
"    for (int particle = get_global_id(0)/NUM_COPIES; particle < NUM_ATOMS; particle += numBlocks) {\n"
"        int index = particle+indexInBlock*PADDED_NUM_ATOMS;\n"
"        mixed4 particleVelm = velm[index];\n"
"        particleVelm.xyz += convert_mixed4(force[index]).xyz*(0.5f*dt*particleVelm.w);\n"
"        if (particleVelm.w != 0)\n"
"            velm[index] = particleVelm;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Copy a set of positions and velocities from the integrator's arrays to the context.\n"
" */\n"
"__kernel void copyDataToContext(__global mixed4* srcVel, __global mixed4* dstVel, __global mixed4* srcPos,\n"
"        __global real4* dstPos, __global int* order, int copy) {\n"
"    const int base = copy*PADDED_NUM_ATOMS;\n"
"    for (int particle = get_global_id(0); particle < NUM_ATOMS; particle += get_global_size(0)) {\n"
"        int index = base+order[particle];\n"
"        dstVel[particle] = srcVel[index];\n"
"        dstPos[particle].xyz = convert_real4(srcPos[index]).xyz;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Copy a set of positions, velocities, and forces from the context to the integrator's arrays.\n"
" */\n"
"__kernel void copyDataFromContext(__global real4* srcForce, __global real4* dstForce, __global mixed4* srcVel,\n"
"        __global mixed4* dstVel, __global real4* srcPos, __global mixed4* dstPos, __global int* order, int copy) {\n"
"    const int base = copy*PADDED_NUM_ATOMS;\n"
"    for (int particle = get_global_id(0); particle < NUM_ATOMS; particle += get_global_size(0)) {\n"
"        int index = base+order[particle];\n"
"        dstForce[index] = srcForce[particle];\n"
"        dstVel[index] = srcVel[particle];\n"
"        dstPos[index].xyz = convert_mixed4(srcPos[particle]).xyz;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Atom positions in one copy have been modified.  Apply the same offsets to all the other copies.\n"
" */\n"
"__kernel void applyCellTranslations(__global mixed4* posq, __global real4* movedPos, __global int* order, int movedCopy) {\n"
"    for (int particle = get_global_id(0); particle < NUM_ATOMS; particle += get_global_size(0)) {\n"
"        int index = order[particle];\n"
"        mixed4 delta = convert_mixed4(movedPos[particle])-posq[movedCopy*PADDED_NUM_ATOMS+index];\n"
"        for (int copy = 0; copy < NUM_COPIES; copy++)\n"
"            posq[copy*PADDED_NUM_ATOMS+index].xyz += delta.xyz;\n"
"    }\n"
"}\n"
"";
const string OpenCLRpmdKernelSources::rpmdContraction = "mixed4 multiplyComplexRealPart(mixed2 c1, mixed4 c2r, mixed4 c2i) {\n"
"    return c1.x*c2r-c1.y*c2i;\n"
"}\n"
"\n"
"mixed4 multiplyComplexImagPart(mixed2 c1, mixed4 c2r, mixed4 c2i) {\n"
"    return c1.x*c2i+c1.y*c2r;\n"
"}\n"
"\n"
"mixed4 multiplyComplexRealPartConj(mixed2 c1, mixed4 c2r, mixed4 c2i) {\n"
"    return c1.x*c2r+c1.y*c2i;\n"
"}\n"
"\n"
"mixed4 multiplyComplexImagPartConj(mixed2 c1, mixed4 c2r, mixed4 c2i) {\n"
"    return c1.x*c2i-c1.y*c2r;\n"
"}\n"
"\n"
"/**\n"
" * Compute the contracted positions\n"
" */\n"
"__kernel void contractPositions(__global mixed4* posq, __global mixed4* contracted) {\n"
"    const int numBlocks = get_global_size(0)/NUM_COPIES;\n"
"    const int blockStart = NUM_COPIES*(get_local_id(0)/NUM_COPIES);\n"
"    const int indexInBlock = get_local_id(0)-blockStart;\n"
"    __local mixed4 q[2*THREAD_BLOCK_SIZE];\n"
"    __local mixed4 temp[2*THREAD_BLOCK_SIZE];\n"
"    __local mixed2 w1[NUM_COPIES];\n"
"    __local mixed2 w2[NUM_CONTRACTED_COPIES];\n"
"    __local mixed4* qreal = &q[blockStart];\n"
"    __local mixed4* qimag = &q[blockStart+get_local_size(0)];\n"
"    __local mixed4* tempreal = &temp[blockStart];\n"
"    __local mixed4* tempimag = &temp[blockStart+get_local_size(0)];\n"
"    if (get_local_id(0) < NUM_COPIES)\n"
"        w1[indexInBlock] = (mixed2) (cos(-indexInBlock*2*M_PI/NUM_COPIES), sin(-indexInBlock*2*M_PI/NUM_COPIES));\n"
"    if (get_local_id(0) < NUM_CONTRACTED_COPIES)\n"
"        w2[indexInBlock] = (mixed2) (cos(-indexInBlock*2*M_PI/NUM_CONTRACTED_COPIES), sin(-indexInBlock*2*M_PI/NUM_CONTRACTED_COPIES));\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (int particle = get_global_id(0)/NUM_COPIES; particle < NUM_ATOMS; particle += numBlocks) {\n"
"        // Load the particle position.\n"
"        \n"
"        mixed4 particlePosq = convert_mixed4(posq[particle+indexInBlock*PADDED_NUM_ATOMS]);\n"
"        qreal[indexInBlock] = particlePosq;\n"
"        qimag[indexInBlock] = (mixed4) (0.0f, 0.0f, 0.0f, 0.0f);\n"
"        \n"
"        // Forward FFT.\n"
"        \n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        __local mixed2* w = w1;\n"
"        FFT_Q_FORWARD\n"
"        if (NUM_CONTRACTED_COPIES > 1) {\n"
"            // Compress the data to remove high frequencies.\n"
"            \n"
"            int start = (NUM_CONTRACTED_COPIES+1)/2;\n"
"            tempreal[indexInBlock] = qreal[indexInBlock];\n"
"            tempimag[indexInBlock] = qimag[indexInBlock];\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            if (indexInBlock < NUM_CONTRACTED_COPIES) {\n"
"                qreal[indexInBlock] = tempreal[indexInBlock < start ? indexInBlock : indexInBlock+(NUM_COPIES-NUM_CONTRACTED_COPIES)];\n"
"                qimag[indexInBlock] = tempimag[indexInBlock < start ? indexInBlock : indexInBlock+(NUM_COPIES-NUM_CONTRACTED_COPIES)];\n"
"            }\n"
"            barrier(CLK_LOCAL_MEM_FENCE);\n"
"            w = w2;\n"
"            FFT_Q_BACKWARD\n"
"        }\n"
"        \n"
"        // Store results.\n"
"        \n"
"        if (indexInBlock < NUM_CONTRACTED_COPIES)\n"
"            contracted[particle+indexInBlock*PADDED_NUM_ATOMS] = (mixed4) (POS_SCALE*qreal[indexInBlock].x, POS_SCALE*qreal[indexInBlock].y, POS_SCALE*qreal[indexInBlock].z, particlePosq.w);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * Apply the contracted forces to all copies.\n"
" */\n"
"__kernel void contractForces(__global real4* force, __global real4* contracted) {\n"
"    const int numBlocks = get_global_size(0)/NUM_COPIES;\n"
"    const int blockStart = NUM_COPIES*(get_local_id(0)/NUM_COPIES);\n"
"    const int indexInBlock = get_local_id(0)-blockStart;\n"
"    __local mixed4 f[2*THREAD_BLOCK_SIZE];\n"
"    __local mixed4 temp[2*THREAD_BLOCK_SIZE];\n"
"    __local mixed2 w1[NUM_COPIES];\n"
"    __local mixed2 w2[NUM_CONTRACTED_COPIES];\n"
"    __local mixed4* freal = &f[blockStart];\n"
"    __local mixed4* fimag = &f[blockStart+get_local_size(0)];\n"
"    __local mixed4* tempreal = &temp[blockStart];\n"
"    __local mixed4* tempimag = &temp[blockStart+get_local_size(0)];\n"
"    if (get_local_id(0) < NUM_COPIES)\n"
"        w1[indexInBlock] = (mixed2) (cos(-indexInBlock*2*M_PI/NUM_COPIES), sin(-indexInBlock*2*M_PI/NUM_COPIES));\n"
"    if (get_local_id(0) < NUM_CONTRACTED_COPIES)\n"
"        w2[indexInBlock] = (mixed2) (cos(-indexInBlock*2*M_PI/NUM_CONTRACTED_COPIES), sin(-indexInBlock*2*M_PI/NUM_CONTRACTED_COPIES));\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    for (int particle = get_global_id(0)/NUM_COPIES; particle < NUM_ATOMS; particle += numBlocks) {\n"
"        // Load the force.\n"
"        \n"
"        int index = particle+indexInBlock*PADDED_NUM_ATOMS;\n"
"        if (indexInBlock < NUM_CONTRACTED_COPIES) {\n"
"            freal[indexInBlock] = convert_mixed4(contracted[index]);\n"
"            fimag[indexInBlock] = (mixed4) (0.0f, 0.0f, 0.0f, 0.0f);\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Forward FFT.\n"
"        \n"
"        __local mixed2* w = w2;\n"
"        if (NUM_CONTRACTED_COPIES > 1) {\n"
"            FFT_F_FORWARD\n"
"        }\n"
"        \n"
"        // Set the high frequency components to 0.\n"
"        \n"
"        int start = (NUM_CONTRACTED_COPIES+1)/2;\n"
"        int end = NUM_COPIES-NUM_CONTRACTED_COPIES+start;\n"
"        tempreal[indexInBlock] = freal[indexInBlock];\n"
"        tempimag[indexInBlock] = fimag[indexInBlock];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        if (indexInBlock >= start) {\n"
"            freal[indexInBlock] = (indexInBlock < end ? (mixed4) (0.0f, 0.0f, 0.0f, 0.0f) : tempreal[indexInBlock-(NUM_COPIES-NUM_CONTRACTED_COPIES)]);\n"
"            fimag[indexInBlock] = (indexInBlock < end ? (mixed4) (0.0f, 0.0f, 0.0f, 0.0f) : tempimag[indexInBlock-(NUM_COPIES-NUM_CONTRACTED_COPIES)]);\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"        w = w1;\n"
"        FFT_F_BACKWARD\n"
"        \n"
"        // Store results.\n"
"\n"
"        force[index] += convert_real4(FORCE_SCALE*freal[indexInBlock]);\n"
"    }\n"
"}\n"
"";
